<!-- translate/tutorial_004.md -->

## 4. さらに制御フローツールについて

これまでに紹介した `while` 文のほかに、Pythonは他の言語でおなじみの制御フローステートメントを、いくつかの独自の工夫を加えて使っています。

### 4.1. if 文

おそらく最もよく知られているステートメントは `if` 文でしょう。例えば、次のようになります。

```python
>>> x = int(input("Please enter an integer: "))
Please enter an integer: 42
>>> if x < 0:
...     x = 0
...     print('負の数なので0にしました')
... elif x == 0:
...     print('ゼロです')
... elif x == 1:
...     print('ひとつです')
... else:
...     print('もっと大きいです')
...
もっと大きいです
```

`elif` の部分はなくてもよく、複数あっても構いません。また、`else` の部分も任意です。キーワード「elif」は「else if」の短縮形で、インデントが深くなりすぎるのを避けるのに便利です。`if ... elif ... elif ...` という連なりは、他の言語に見られる `switch` 文や `case` 文の代わりになります。

### 4.2. for 文

Pythonの `for` 文は、C言語やPascalで慣れているものとは少し異なります。Pascalのように常に等差数列をループしたり、C言語のようにループのステップと停止条件を両方定義できるようにするのではなく、Pythonの `for` 文は、任意のシーケンス（リストや文字列など）のアイテムを、シーケンスに出現する順序で反復処理（ループ）します。例えば、次のようになります。

```python
>>> # いくつかの文字列の長さを測る
... words = ['cat', 'window', 'defenestrate']
>>> for w in words:
...     print(w, len(w))
...
cat 3
window 6
defenestrate 12
```

コレクション（リストや辞書など）をループ処理しながら、その同じコレクションを変更するコードは、正しく書くのが難しいことがあります。代わりに、コレクションのコピーをループするか、新しいコレクションを作成する方が、通常はより簡単で分かりやすいです。

```python
# 戦略: コピーをループする
for user, status in users.copy().items():
    if status == 'inactive':
        del users[user]

# 戦略: 新しいコレクションを作成する
active_users = {}
for user, status in users.items():
    if status == 'active':
        active_users[user] = status
```

### 4.3. range() 関数

もし連続した数値をループ処理する必要があるなら、組み込み関数の `range()` が便利です。これは等差数列を生成します。

```python
>>> for i in range(5):
...     print(i)
...
0
1
2
3
4
```

指定された終了点は、生成されるシーケンスの一部にはなりません。`range(10)` は10個の値を生成しますが、それは長さ10のシーケンスの有効なインデックス（0から9まで）です。rangeの開始点を別の数値にしたり、異なる増分（負の数も可能で、これは「ステップ」と呼ばれることもあります）を指定することもできます。

```python
>>> list(range(5, 10))


>>> list(range(0, 10, 3))


>>> list(range(-10, -100, -30))
[-10, -40, -70]
```

シーケンスのインデックスをループ処理するには、次のように `range()` と `len()` を組み合わせることができます。

```python
>>> a = ['Mary', 'had', 'a', 'little', 'lamb']
>>> for i in range(len(a)):
...     print(i, a[i])
...
0 Mary
1 had
2 a
3 little
4 lamb
```

しかし、ほとんどの場合、`enumerate()` 関数を使う方が便利です。「ループのテクニック」の章を参照してください。

`range` をそのまま表示しようとすると、少し奇妙なことが起こります。

```python
>>> range(10)
range(0, 10)
```

`range()` が返すオブジェクトは、多くの点でリストのように振る舞いますが、実際にはリストではありません。これは、ループ処理されるときに要求されたシーケンスの連続したアイテムを返すオブジェクトですが、実際にリストを作成するわけではないため、スペースを節約できます。

このようなオブジェクトを**イテラブル (iterable)** と呼びます。つまり、供給が尽きるまで連続したアイテムを取得できるものを期待する関数や構文の対象として適している、ということです。`for` 文がそのような構文であることはすでに見てきました。イテラブルを受け取る関数の例としては `sum()` があります。

```python
>>> sum(range(4))  # 0 + 1 + 2 + 3
6
```

後ほど、イテラブルを返したり、引数として受け取ったりする他の関数も見ていきます。「データ構造」の章では `list()` についてさらに詳しく説明します。

### 4.4. break, continue, そしてループの else 節

`break` 文は、C言語と同様に、最も内側の `for` または `while` ループから抜け出します。

ループ文には `else` 節を持つことができます。これは、ループがイテラブルを使い果たして終了したとき（`for` の場合）や、条件が偽になったとき（`while` の場合）に実行されますが、ループが `break` 文で中断されたときには実行されません。これは、素数を探す次のループで例示されています。

```python
>>> for n in range(2, 10):
...     for x in range(2, n):
...         if n % x == 0:
...             print(n, 'は', x, '*', n//x, 'と等しい')
...             break
...     else:
...         # ループが break せずに完了した場合
...         print(n, 'は素数です')
...
2 は素数です
3 は素数です
4 は 2 * 2 と等しい
5 は素数です
6 は 2 * 3 と等しい
7 は素数です
8 は 2 * 4 と等しい
9 は 3 * 3 と等しい
```
（はい、これが正しいコードです。よく見てください。`else` 節は `if` 文ではなく、`for` ループに属しています。）

ループと共に使われる場合、`else` 節は `if` 文の `else` 節よりも `try` 文の `else` 節と共通点があります。`try` 文の `else` 節は例外が発生しなかったときに実行され、ループの `else` 節は `break` が発生しなかったときに実行されます。`try` 文と例外については、「例外を処理する」を参照してください。

`continue` 文もC言語から借用したもので、ループの次のイテレーション（繰り返し）に進みます。

```python
>>> for num in range(2, 10):
...     if num % 2 == 0:
...         print("偶数が見つかりました", num)
...         continue
...     print("奇数が見つかりました", num)
...
偶数が見つかりました 2
奇数が見つかりました 3
偶数が見つかりました 4
奇数が見つかりました 5
偶数が見つかりました 6
奇数が見つかりました 7
偶数が見つかりました 8
奇数が見つかりました 9
```

### 4.5. pass 文

`pass` 文は何も行いません。構文的に文が必要だけれども、プログラムが何もアクションを必要としない場合に使用できます。例えば、

```python
>>> while True:
...     pass  # キーボード割り込み (Ctrl+C) を待つためのビジーウェイト
...
```

これは、最小限のクラスを作成するためによく使われます。

```python
>>> class MyEmptyClass:
...     pass
...
```

`pass` が使えるもう一つの場所は、新しいコードを書いているときに関数や条件分岐の本体のプレースホルダー（仮置き）として使うことです。これにより、より抽象的なレベルで考え続けることができます。`pass` は黙って無視されます。

```python
>>> def initlog(*args):
...     pass   # ここを実装するのを忘れないように！
...
```

### 4.6. 関数の定義

指定された境界までのフィボナッチ数列を書き出す関数を作成できます。

```python
>>> def fib(n):    # n までのフィボナッチ数列を書き出す
...     """n までのフィボナッチ数列を表示する"""
...     a, b = 0, 1
...     while a < n:
...         print(a, end=' ')
...         a, b = b, a+b
...     print()
...
>>> # 定義したばかりの関数を呼び出す
... fib(2000)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
```

キーワード `def` は関数の定義を開始します。その後に、関数名と丸括弧で囲まれた仮引数のリストが続かなければなりません。関数の本体を形成する文は次の行から始まり、インデントする必要があります。

関数の本体の最初の文は、任意で文字列リテラルにすることができます。この文字列リテラルは、関数の**ドキュメンテーション文字列**、または**docstring**と呼ばれます。（docstringについての詳細は「ドキュメンテーション文字列」のセクションにあります。）docstringを使ってオンラインや印刷用のドキュメントを自動生成したり、ユーザーが対話的にコードを閲覧できるようにするツールがあります。自分で書くコードにdocstringを含めるのは良い習慣なので、癖にしておきましょう。

関数の実行は、その関数のローカル変数に使われる新しいシンボルテーブルを導入します。より正確に言えば、関数内でのすべての変数代入は、その値をローカルシンボルテーブルに格納します。一方、変数の参照は、まずローカルシンボルテーブルを探し、次にそれを囲む関数のローカルシンボルテーブル、次にグローバルシンボルテーブル、そして最後に組み込み名のテーブルを探します。したがって、グローバル変数やそれを囲む関数の変数は、関数内で直接値を代入することはできません（ただし、グローバル変数の場合は `global` 文で、囲む関数の変数の場合は `nonlocal` 文で指定されていれば可能です）。参照することは可能です。

関数呼び出しの際の実際の引数（実引数）は、呼び出された関数のローカルシンボルテーブルに導入されます。したがって、引数は**値渡し (call by value)** で渡されます（ここでの「値」は常にオブジェクトの参照であり、オブジェクトの値そのものではありません）¹。ある関数が別の関数を呼び出したり、再帰的に自身を呼び出したりすると、その呼び出しのために新しいローカルシンボルテーブルが作成されます。

関数定義は、関数名を現在のシンボルテーブル内の関数オブジェクトに関連付けます。インタプリタは、その名前が指すオブジェクトをユーザー定義関数として認識します。他の名前も同じ関数オブジェクトを指すことができ、その関数にアクセスするために使うこともできます。

```python
>>> fib
<function fib at 10042ed0>
>>> f = fib
>>> f(100)
0 1 1 2 3 5 8 13 21 34 55 89
```

他の言語から来た人は、`fib` は値を返さないので関数ではなくプロシージャだと反対するかもしれません。実際には、`return` 文のない関数でさえ、値を返します。ただし、それはかなり退屈な値です。この値は `None` と呼ばれます（組み込み名です）。`None` という値は、それが唯一書き出される値である場合、通常インタプリタによって表示が抑制されます。どうしても見たい場合は `print()` を使えば見ることができます。

```python
>>> fib(0)

>>> print(fib(0))
None
```

フィボナッチ数列を表示する代わりに、その数値のリストを返す関数を書くのは簡単です。

```python
>>> def fib2(n):  # n までのフィボナッチ数列を返す
...     """n までのフィボナッチ数列を含むリストを返す"""
...     result = []
...     a, b = 0, 1
...     while a < n:
...         result.append(a)    # 下記参照
...         a, b = b, a+b
...     return result
...
>>> f100 = fib2(100)    # 呼び出す
>>> f100                # 結果を書き出す
```

この例も、いつものように、いくつかの新しいPythonの機能を示しています。

*   `return` 文は、関数から値を返します。式の引数がない `return` は `None` を返します。関数の終わりまで実行が進んだ場合も `None` を返します。

*   `result.append(a)` という文は、リストオブジェクト `result` の**メソッド**を呼び出します。メソッドとは、オブジェクトに「属している」関数で、`obj.methodname` という形式で名前が付けられます。ここで `obj` は何らかのオブジェクト（式でもよい）で、`methodname` はそのオブジェクトの型によって定義されたメソッドの名前です。異なる型は異なるメソッドを定義します。異なる型のメソッドが同じ名前を持っていても、曖昧さを引き起こすことはありません。（クラスを使って独自のオブジェクト型とメソッドを定義することも可能です。「クラス」の章を参照してください。）この例で示されている `append()` メソッドはリストオブジェクト用に定義されており、リストの末尾に新しい要素を追加します。この例では `result = result + [a]` と同等ですが、より効率的です。

### 4.7. 関数定義についてもう少し

可変個の引数を持つ関数を定義することも可能です。3つの形式があり、これらは組み合わせることができます。

#### 4.7.1. デフォルト引数値

最も便利な形式は、1つ以上の引数にデフォルト値を指定することです。これにより、定義されているよりも少ない引数で呼び出すことができる関数が作成できます。例えば、

```python
def ask_ok(prompt, retries=4, reminder='もう一度試してください！'):
    while True:
        ok = input(prompt)
        if ok in ('y', 'ye', 'yes'):
            return True
        if ok in ('n', 'no', 'nop', 'nope'):
            return False
        retries = retries - 1
        if retries < 0:
            raise ValueError('不正なユーザー応答です')
        print(reminder)
```

この関数はいくつかの方法で呼び出すことができます。

*   必須引数のみを与える: `ask_ok('本当に終了しますか？')`
*   オプション引数の1つを与える: `ask_ok('ファイルを上書きしてもよろしいですか？', 2)`
*   あるいはすべての引数を与える: `ask_ok('ファイルを上書きしてもよろしいですか？', 2, 'さあ、yesかnoだけで答えてください！')`

この例では `in` キーワードも導入されています。これは、シーケンスが特定の価値を含むかどうかをテストします。

デフォルト値は、関数が定義されたスコープで、定義時に評価されます。したがって、

```python
i = 5

def f(arg=i):
    print(arg)

i = 6
f()
```

は `5` を表示します。

**重要な警告:** デフォルト値は一度しか評価されません。これは、デフォルトがリスト、辞書、またはほとんどのクラスのインスタンスのようなミュータブルなオブジェクトである場合に違いを生じさせます。例えば、次の関数は、後続の呼び出しで渡された引数を蓄積します。

```python
def f(a, L=[]):
    L.append(a)
    return L

print(f(1))
print(f(2))
print(f(3))
```

これは次のように表示します。

```



```

後続の呼び出し間でデフォルトを共有したくない場合は、代わりに次のように関数を書くことができます。

```python
def f(a, L=None):
    if L is None:
        L = []
    L.append(a)
    return L
```

#### 4.7.2. キーワード引数

関数は `kwarg=value` という形式の**キーワード引数**を使って呼び出すこともできます。例えば、次の関数は、

```python
def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):
    print("-- このオウムは", action, "しないでしょう", end=' ')
    print("もし", voltage, "ボルトを流したら。")
    print("-- なんて素敵な羽毛なんだ、", type)
    print("-- こいつは", state, "だ！")
```

1つの必須引数 (`voltage`) と3つのオプション引数 (`state`, `action`, `type`) を受け入れます。この関数は、次のいずれの方法でも呼び出すことができます。

```python
parrot(1000)                                          # 1つの位置引数
parrot(voltage=1000)                                  # 1つのキーワード引数
parrot(voltage=1000000, action='VOOOOOM')             # 2つのキーワード引数
parrot(action='VOOOOOM', voltage=1000000)             # 2つのキーワード引数 (順序は問わない)
parrot('a million', 'bereft of life', 'jump')         # 3つの位置引数
parrot('a thousand', state='pushing up the daisies')  # 1つの位置引数、1つのキーワード引数
```

しかし、次の呼び出しはすべて無効です。

```python
parrot()                     # 必須引数が欠けている
parrot(voltage=5.0, 'dead')  # キーワード引数の後にキーワードなし引数がある
parrot(110, voltage=220)     # 同じ引数に重複して値を指定している
parrot(actor='John Cleese')  # 不明なキーワード引数
```

関数呼び出しでは、キーワード引数は位置引数の後に来なければなりません。渡されるすべてのキーワード引数は、関数が受け入れる引数のいずれかと一致しなければならず（例えば、`actor` は `parrot` 関数の有効な引数ではありません）、その順序は重要ではありません。これには必須引数も含まれます（例えば `parrot(voltage=1000)` も有効です）。どの引数も値を複数回受け取ることはできません。この制限のために失敗する例を次に示します。

```python
>>> def function(a):
...     pass
...
>>> function(0, a=0)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: function() got multiple values for argument 'a'
```

`**name` という形式の最後の仮引数が存在する場合、それは仮引数に対応しないすべてのキーワード引数を含む辞書（「マップ型 --- dict」を参照）を受け取ります。これは、仮引数リストを超える位置引数を含むタプルを受け取る `*name` という形式の仮引数と組み合わせることができます。（`*name` は `**name` の前になければなりません。）例えば、次のような関数を定義すると、

```python
def cheeseshop(kind, *arguments, **keywords):
    print("--", kind, "はありますか？")
    print("-- 申し訳ありません、", kind, "はすべて品切れです。")
    for arg in arguments:
        print(arg)
    print("-" * 40)
    for kw in keywords:
        print(kw, ":", keywords[kw])
```

次のように呼び出すことができます。

```python
cheeseshop("Limburger", "とても水っぽいんですよ、旦那。",
           "本当に本当に、とーっても水っぽいんですってば。",
           shopkeeper="Michael Palin",
           client="John Cleese",
           sketch="Cheese Shop Sketch")
```

そしてもちろん、次のように表示されます。

```
-- Limburger はありますか？
-- 申し訳ありません、Limburger はすべて品切れです。
とても水っぽいんですよ、旦那。
本当に本当に、とーっても水っぽいんですってば。
----------------------------------------
shopkeeper : Michael Palin
client : John Cleese
sketch : Cheese Shop Sketch
```

キーワード引数が表示される順序は、関数呼び出しで提供された順序と一致することが保証されている点に注意してください。

#### 4.7.3. 特殊な引数

デフォルトでは、引数はPython関数に位置によって、またはキーワードによって明示的に渡すことができます。読みやすさとパフォーマンスのために、開発者が関数定義を見るだけでアイテムが位置によって、位置またはキーワードによって、またはキーワードによって渡されるかを判断できるように、引数の渡し方を制限することは理にかなっています。

関数定義は次のようになります。

```python
def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):
      -----------    ----------     ----------
        |             |                  |
        |      位置またはキーワード      |
        |                                - キーワードのみ
         -- 位置のみ
```

ここで `/` と `*` はオプションです。もし使われた場合、これらの記号は、引数がどのように関数に渡されるかによって引数の種類を示します：位置のみ (positional-only)、位置またはキーワード (positional-or-keyword)、キーワードのみ (keyword-only)。

##### 4.7.3.1. 位置またはキーワード引数

もし `/` と `*` が関数定義に存在しない場合、引数は位置またはキーワードによって関数に渡すことができます。

##### 4.7.3.2. 位置のみの引数

もう少し詳しく見ると、特定の引数を**位置のみ**としてマークすることが可能です。位置のみの場合、引数の順序が重要になり、引数をキーワードで渡すことはできません。位置のみの引数は、`/`（フォワードスラッシュ）の前に置かれます。`/` は、位置のみの引数を残りの引数から論理的に分離するために使われます。関数定義に `/` がなければ、位置のみの引数はありません。

`/` の後の引数は、位置またはキーワード、あるいはキーワードのみにすることができます。

##### 4.7.3.3. キーワードのみの引数

引数を**キーワードのみ**としてマークするには、つまり引数がキーワード引数で渡されなければならないことを示すには、引数リストの最初のキーワードのみの引数の直前に `*` を置きます。

##### 4.7.3.4. 関数の例

マーカー `/` と `*` に細心の注意を払いながら、次の関数定義の例を考えてみましょう。

```python
>>> def standard_arg(arg):
...     print(arg)
...
>>> def pos_only_arg(arg, /):
...     print(arg)
...
>>> def kwd_only_arg(*, arg):
...     print(arg)
...
>>> def combined_example(pos_only, /, standard, *, kwd_only):
...     print(pos_only, standard, kwd_only)
```

最初の関数定義 `standard_arg` は最も馴染み深い形式で、呼び出し規約に制限を設けず、引数は位置またはキーワードで渡すことができます。

```python
>>> standard_arg(2)
2
>>> standard_arg(arg=2)
2
```

2番目の関数 `pos_only_arg` は、関数定義に `/` があるため、位置引数のみを使用するように制限されています。

```python
>>> pos_only_arg(1)
1
>>> pos_only_arg(arg=1)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: pos_only_arg() got some positional-only arguments passed as keyword arguments: 'arg'
```

3番目の関数 `kwd_only_args` は、関数定義に `*` が示しているように、キーワード引数のみを許可します。

```python
>>> kwd_only_arg(3)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: kwd_only_arg() takes 0 positional arguments but 1 was given
>>> kwd_only_arg(arg=3)
3
```

そして最後の関数は、同じ関数定義で3つすべての呼び出し規約を使用します。

```python
>>> combined_example(1, 2, 3)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: combined_example() takes 2 positional arguments but 3 were given
>>> combined_example(1, 2, kwd_only=3)
1 2 3
>>> combined_example(1, standard=2, kwd_only=3)
1 2 3
>>> combined_example(pos_only=1, standard=2, kwd_only=3)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: combined_example() got some positional-only arguments passed as keyword arguments: 'pos_only'
```

最後に、位置引数名と、`name` をキーとして持つ `**kwds` との間で衝突の可能性があるこの関数定義を考えてみてください。

```python
def foo(name, **kwds):
    return 'name' in kwds```

キーワード `name` は常に最初の引数に束縛されるため、`True` を返させるような呼び出し方は不可能です。例えば、

```python
>>> foo(1, **{'name': 2})
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: foo() got multiple values for argument 'name'
```

しかし、`/` (位置のみの引数) を使うと、`name` を位置引数として、そして `'name'` をキーワード引数のキーとして許可するため、これが可能になります。

```python
def foo(name, /, **kwds):
    return 'name' in kwds
>>> foo(1, **{'name': 2})
True
```
言い換えれば、位置のみの引数の名前は、曖昧さなく `**kwds` で使用することができます。

##### 4.7.3.5. まとめ

どの引数を関数定義で使用するかは、ユースケースによって決まります。

```python
def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):```

ガイドラインとして：

*   引数名をユーザーに利用させたくない場合は、**位置のみ**を使用します。これは、引数名に実質的な意味がない場合、関数が呼び出される際の引数の順序を強制したい場合、またはいくつかの位置引数と任意のキーワード引数を取る必要がある場合に便利です。
*   名前が意味を持ち、関数定義が名前を明示することでより理解しやすくなる場合、またはユーザーが渡される引数の位置に依存するのを防ぎたい場合は、**キーワードのみ**を使用します。
*   APIの場合、将来的に引数名が変更された場合にAPIの互換性が壊れるのを防ぐために、**位置のみ**を使用します。

#### 4.7.4. 任意引数リスト

最後に、最も使用頻度の低いオプションは、関数が任意の数の引数で呼び出せることを指定することです。これらの引数はタプルにまとめられます（「タプルとシーケンス」を参照）。可変個の引数の前に、0個以上の通常の引数を置くことができます。

```python
def write_multiple_items(file, separator, *args):
    file.write(separator.join(args))
```

通常、これらの可変長引数は、関数に渡される残りのすべての入力引数を集めるため、仮引数リストの最後に置かれます。`*args` 引数の後に現れる仮引数は「キーワードのみ」の引数となり、位置引数としてではなくキーワードとしてのみ使用できます。

```python
>>> def concat(*args, sep="/"):
...     return sep.join(args)
...
>>> concat("earth", "mars", "venus")
'earth/mars/venus'
>>> concat("earth", "mars", "venus", sep=".")
'earth.mars.venus'
```

#### 4.7.5. 引数リストのアンパック

引数がすでにリストやタプルに入っているが、別々の位置引数を必要とする関数呼び出しのためにアンパック（展開）する必要がある場合、逆の状況が発生します。例えば、組み込みの `range()` 関数は、別々の `start` と `stop` 引数を期待します。もしそれらが別々に利用できない場合は、`*` 演算子を使って関数呼び出しを書き、リストやタプルから引数をアンパックします。

```python
>>> list(range(3, 6))            # 別々の引数での通常の呼び出し

>>> args =
>>> list(range(*args))           # リストからアンパックされた引数での呼び出し

```

同様に、辞書は `**` 演算子でキーワード引数を渡すことができます。

```python
>>> def parrot(voltage, state='a stiff', action='voom'):
...     print("-- このオウムは", action, "しないでしょう", end=' ')
...     print("もし", voltage, "ボルトを流したら。", end=' ')
...     print("こいつは", state, "だ！")
...
>>> d = {"voltage": "400万", "state": "完全に息絶えてる", "action": "VOOM"}
>>> parrot(**d)
-- このオウムは VOOM しないでしょう もし 400万 ボルトを流したら。 こいつは 完全に息絶えてる だ！
```

#### 4.7.6. ラムダ式

`lambda` キーワードを使うと、小さな無名関数を作成できます。この関数は2つの引数の合計を返します: `lambda a, b: a+b`。ラムダ関数は、関数オブジェクトが必要とされる場所ならどこでも使用できます。構文的には単一の式に制限されています。意味的には、通常の関数定義の単なる糖衣構文（syntactic sugar）です。ネストされた関数定義のように、ラムダ関数はそれを含むスコープの変数を参照できます。

```python
>>> def make_incrementor(n):
...     return lambda x: x + n
...
>>> f = make_incrementor(42)
>>> f(0)
42
>>> f(1)
43
```

上の例では、ラムダ式を使って関数を返しています。別の使い方として、小さな関数を引数として渡すことがあります。

```python
>>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]
>>> pairs.sort(key=lambda pair: pair)
>>> pairs
[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]
```

#### 4.7.7. ドキュメンテーション文字列

ドキュメンテーション文字列（docstring）の内容とフォーマットに関するいくつかの慣習があります。

*   最初の行は常に、オブジェクトの目的の短く簡潔な要約であるべきです。簡潔にするため、オブジェクトの名前や型を明示的に述べるべきではありません（名前がたまたま関数の操作を説明する動詞である場合を除く）。この行は、大文字で始まり、ピリオドで終わるべきです。

*   ドキュメンテーション文字列にさらに行がある場合、2行目は空白にし、要約と残りの説明を視覚的に分離するべきです。続く行は、オブジェクトの呼び出し規約、副作用などを説明する1つ以上の段落であるべきです。

*   Pythonパーサーは、Pythonの複数行文字列リテラルからインデントを取り除かないので、ドキュメンテーションを処理するツールが必要に応じてインデントを取り除く必要があります。これは次の慣習を用いて行われます。文字列の最初の行の後の最初の空でない行が、ドキュメンテーション文字列全体のインデントの量を決定します。（最初の行は通常、文字列の開始クォートに隣接しているため、そのインデントは文字列リテラルでは明らかでないため、使用できません。）このインデントと「同等」の空白が、文字列のすべての行の先頭から取り除かれます。インデントが少ない行は出現すべきではありませんが、もし出現した場合は、そのすべての先頭の空白が取り除かれるべきです。空白の同等性は、タブを展開した後（通常は8スペース）にテストされるべきです。

複数行のdocstringの例を次に示します。

```python
>>> def my_function():
...     """何もしないが、それをドキュメント化する。
...
...     いや、本当に、何もしません。
...     """
...     pass
...
>>> print(my_function.__doc__)
何もしないが、それをドキュメント化する。

    いや、本当に、何もしません。
```

#### 4.7.8. 関数アノテーション

関数アノテーションは、ユーザー定義関数で使用される型に関する完全にオプションのメタデータ情報です（詳細についてはPEP 3107およびPEP 484を参照）。

アノテーションは、関数の `__annotations__` 属性に辞書として格納され、関数の他の部分には何の影響も与えません。引数のアノテーションは、引数名の後のコロンに続けて、アノテーションの値に評価される式を記述して定義します。戻り値のアノテーションは、リテラルの `->` に続けて式を、引数リストと `def` 文の終わりを示すコロンの間に記述して定義します。次の例では、必須引数、オプション引数、および戻り値がアノテーションされています。

```python
>>> def f(ham: str, eggs: str = 'eggs') -> str:
...     print("アノテーション:", f.__annotations__)
...     print("引数:", ham, eggs)
...     return ham + ' and ' + eggs
...
>>> f('spam')
アノテーション: {'ham': <class 'str'>, 'return': <class 'str'>, 'eggs': <class 'str'>}
引数: spam eggs
'spam and eggs'
```

### 4.8. ちょっと一息：コーディングスタイル

これから、より長く、より複雑なPythonのコードを書き始めるにあたり、コーディングスタイルについて話す良い機会です。ほとんどの言語は、さまざまなスタイルで書く（または、より簡潔に言えば、フォーマットする）ことができます。あるスタイルは他のスタイルよりも読みやすいものです。他の人があなたのコードを読みやすくすることは常に良い考えであり、良いコーディングスタイルを採用することは、そのために非常に役立ちます。

Pythonでは、PEP 8がほとんどのプロジェクトが準拠するスタイルガイドとして登場しました。それは非常に読みやすく、目に優しいコーディングスタイルを推進しています。すべてのPython開発者は、いつかそれを読むべきです。ここに、あなたのために抽出された最も重要なポイントがあります。

*   **4スペースのインデントを使用し、タブは使用しない。**
    4スペースは、小さなインデント（より深いネストを可能にする）と大きなインデント（読みやすい）の良い妥協点です。タブは混乱を招くので、使わないのが一番です。

*   **1行が79文字を超えないように行を折り返す。**
    これにより、小さなディスプレイのユーザーを助け、大きなディスプレイで複数のコードファイルを並べて表示することが可能になります。

*   **関数やクラス、そして関数内の大きなコードブロックを区切るために空白行を使用する。**

*   **可能な限り、コメントは独立した行に書く。**

*   **docstringを使用する。**

*   **演算子の周りとコンマの後にスペースを使い、括弧構造の直内側には使わない。** `a = f(1, 2) + g(3, 4)` のように。

*   **クラスと関数の名前を一貫して付ける。** 慣習では、クラスには `UpperCamelCase` を、関数とメソッドには `lowercase_with_underscores` を使用します。最初のメソッド引数の名前には常に `self` を使用します（クラスとメソッドの詳細については「クラスを初めて見る」を参照）。

*   **コードが国際的な環境で使用されることを意図している場合は、特殊なエンコーディングを使用しない。** PythonのデフォルトであるUTF-8、あるいはプレーンなASCIIが、どの場合でも最も効果的です。

*   **同様に、異なる言語を話す人々がコードを読んだり保守したりする可能性が少しでもある場合は、識別子に非ASCII文字を使用しない。**

---
**脚注**

<sup>1</sup> 実際には、**オブジェクト参照渡し (call by object reference)** の方がより良い説明でしょう。なぜなら、ミュータブルなオブジェクトが渡された場合、呼び出し元は、呼び出された側がそのオブジェクトに加えた変更（リストに挿入されたアイテムなど）を見ることができるからです。
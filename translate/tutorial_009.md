<!-- translate/tutorial_009.md -->

# 9. クラス

クラスは、データと機能性を一つにまとめるための手段を提供します。新しいクラスを作成すると、新しい「型」のオブジェクトが作られ、その型の新しいインスタンスを生成できるようになります。各クラスインスタンスは、自身の状態を維持するための属性を持つことができます。また、クラスインスタンスは、その状態を変更するためのメソッド（そのクラスによって定義される）を持つこともできます。

他のプログラミング言語と比較して、Pythonのクラスメカニズムは、最小限の新しい構文とセマンティクスでクラス機能を追加します。これは、C++とModula-3に見られるクラスメカニズムを組み合わせたものです。Pythonのクラスは、オブジェクト指向プログラミングの標準的な機能をすべて提供します。クラスの継承メカニズムは複数の基底クラスを許容し、派生クラスは基底クラスの任意のメソッドを上書き（オーバーライド）でき、メソッドは同じ名前の基底クラスのメソッドを呼び出すことができます。オブジェクトは、任意の量・種類のデータを含むことができます。モジュールと同様に、クラスもPythonの動的な性質を持っており、実行時に作成され、作成後にさらに変更することが可能です。

C++の用語で言えば、通常、クラスメンバ（データメンバを含む）は`public`（公開）であり（後述の「プライベート変数」を参照）、すべてのメンバ関数は`virtual`（仮想）です。Modula-3のように、メソッドからオブジェクトのメンバを参照するための短縮形はありません。メソッド関数は、オブジェクト自身を表す明示的な第一引数とともに宣言され、この引数は呼び出し時に暗黙的に提供されます。Smalltalkのように、クラス自身もオブジェクトです。これにより、インポートや名前変更のセマンティクスが提供されます。C++やModula-3とは異なり、組み込み型をユーザーによる拡張の基底クラスとして使用できます。また、C++のように、特殊な構文を持つほとんどの組み込み演算子（算術演算子、添字アクセスなど）は、クラスインスタンス用に再定義できます。

（クラスについて話すための世界共通の用語がないため、時折SmalltalkとC++の用語を使います。Modula-3のオブジェクト指向セマンティクスはC++よりもPythonに近いので、Modula-3の用語を使いたいところですが、それを知っている読者はほとんどいないでしょう。）

## 9.1. 名前とオブジェクトについて

オブジェクトは個性を持ち、複数の名前（複数のスコープ内）が同じオブジェクトに紐付けられることがあります。これは他の言語では「エイリアシング（aliasing）」として知られています。Pythonを初めて学ぶ際にはこの点は見過ごされがちで、イミュータブルな基本型（数値、文字列、タプル）を扱う際には安全に無視できます。しかし、エイリアシングは、リストや辞書、その他ほとんどのミュータブルなオブジェクトが関わるPythonコードのセマンティクスに、驚くべき影響を与える可能性があります。エイリアスはある面でポインタのように振る舞うため、これは通常、プログラムにとって有益な形で利用されます。例えば、オブジェクトを渡す処理は、実装上はポインタが渡されるだけなので低コストです。また、関数が引数として渡されたオブジェクトを変更した場合、呼び出し元はその変更を認識できます。これにより、Pascalのように2つの異なる引数渡しメカニズムは不要になります。

## 9.2. Pythonのスコープと名前空間

クラスを紹介する前に、まずPythonのスコープ規則について説明しなければなりません。クラス定義は名前空間でいくつかの巧妙なトリックを使っているので、何が起こっているかを完全に理解するためには、スコープと名前空間がどのように機能するかを知る必要があります。ちなみに、このテーマに関する知識は、どんな上級Pythonプログラマにとっても役立ちます。

まず、いくつかの定義から始めましょう。

**名前空間（namespace）** とは、名前からオブジェクトへのマッピングです。ほとんどの名前空間は現在Pythonの辞書として実装されていますが、通常はそのことを意識することはありません（パフォーマンス以外では）。そして、将来変更される可能性があります。名前空間の例としては、組み込み名の集合（`abs()`のような関数や組み込み例外名を含む）、モジュール内のグローバル名、関数呼び出しにおけるローカル名などがあります。ある意味では、オブジェクトの属性の集合も名前空間を形成します。名前空間について知っておくべき重要なことは、**異なる名前空間にある名前の間には全く関係がない**ということです。例えば、2つの異なるモジュールが両方とも`maximize`という関数を定義しても混乱は起きません。モジュールの利用者は、モジュール名を頭に付ける必要があるからです。

ところで、私はドット（`.`）に続くすべての名前を **属性（attribute）** という言葉で表現します。例えば、式 `z.real` において、`real` はオブジェクト `z` の属性です。厳密に言えば、モジュール内の名前への参照は属性参照です。式 `modname.funcname` では、`modname` はモジュールオブジェクトであり、`funcname` はその属性です。この場合、モジュールの属性とモジュール内で定義されたグローバル名との間には直接的なマッピングが存在します。それらは同じ名前空間を共有しているのです！ ¹

属性は読み取り専用（read-only）の場合と、書き込み可能（writable）な場合があります。後者の場合、属性への代入が可能です。モジュールの属性は書き込み可能です。`modname.the_answer = 42` のように書くことができます。書き込み可能な属性は `del` 文で削除することもできます。例えば、`del modname.the_answer` は `modname` という名前のオブジェクトから属性 `the_answer` を削除します。

名前空間は異なるタイミングで作成され、異なる寿命を持ちます。組み込み名を含む名前空間は、Pythonインタプリタが起動する際に作成され、決して削除されません。モジュールのグローバル名前空間は、モジュール定義が読み込まれるときに作成されます。通常、モジュールの名前空間もインタプリタが終了するまで存続します。スクリプトファイルから読み込まれるか、対話的に実行されるかにかかわらず、インタプリタのトップレベルの呼び出しで実行される文は `__main__` というモジュールの一部と見なされるため、それら自身のグローバル名前空間を持ちます。（組み込み名は実際には `builtins` というモジュールの中に存在します。）

関数のローカル名前空間は、関数が呼び出されるときに作成され、関数が戻るか、関数内で処理されない例外が発生したときに削除されます。（実際には、何が起こるかを説明するには「忘れ去られる」という方が適切でしょう。）もちろん、再帰的な呼び出しはそれぞれ独自のローカル名前空間を持ちます。

**スコープ（scope）** とは、Pythonプログラムのテキスト上の領域であり、そこでは名前空間が「直接アクセス可能」です。「直接アクセス可能」とは、修飾なしの名前への参照が、その名前空間内で名前を見つけようと試みることを意味します。

スコープは静的に決定されますが、動的に使用されます。実行中の任意の時点で、少なくとも3つ、場合によっては4つのネストされたスコープが存在し、それらの名前空間に直接アクセスできます。

1.  **最も内側のスコープ**：最初に検索され、ローカル名を含みます。
2.  **エンクロージングスコープ（enclosing scopes）**：最も近いスコープから順に検索され、それを囲む関数（のスコープ）が該当します。非ローカル（non-local）かつ非グローバル（non-global）な名前を含みます。
3.  **その一つ外のスコープ**：次に検索され、現在のモジュールのグローバル名を含みます。
4.  **最も外側のスコープ**：最後に検索され、組み込み名を含む名前空間です。

名前が `global` と宣言されると、すべての参照と代入はモジュールのグローバル名を含むスコープに直接行われます。最も内側のスコープの外側で見つかった変数を再束縛（rebind）するには、`nonlocal` 文を使用できます。`nonlocal` と宣言されていない場合、それらの変数は読み取り専用です（そのような変数に書き込もうとすると、最も内側のスコープに新しいローカル変数が作成されるだけで、同じ名前の外側の変数は変更されません）。

通常、ローカルスコープは（テキスト上の）現在の関数のローカル名を参照します。関数の外側では、ローカルスコープはグローバルスコープと同じ名前空間、つまりモジュールの名前空間を参照します。クラス定義は、ローカルスコープにさらに別の名前空間を配置します。

スコープはテキスト的に決定されることを理解することが重要です。モジュールで定義された関数のグローバルスコープは、その関数がどこから、またはどのエイリアスで呼び出されようとも、そのモジュールの名前空間です。一方で、実際の名前の検索は実行時に動的に行われます。しかし、言語の定義は「コンパイル」時に静的な名前解決へと進化しているので、動的な名前解決に依存しないでください！（実際、ローカル変数はすでに静的に決定されています。）

Pythonの特殊な癖として、`global` 文も `nonlocal` 文も有効でない場合、名前への代入は常に最も内側のスコープに行われます。代入はデータをコピーするのではなく、名前をオブジェクトに束縛（bind）するだけです。削除も同様です。`del x` という文は、ローカルスコープが参照する名前空間から `x` の束縛を削除します。実際、新しい名前を導入するすべての操作はローカルスコープを使用します。特に、`import` 文と関数定義は、モジュール名や関数名をローカルスコープに束縛します。

`global` 文は、特定の変数がグローバルスコープに存在し、そこで再束縛されるべきであることを示すために使用できます。`nonlocal` 文は、特定の変数がエンクロージングスコープに存在し、そこで再束縛されるべきであることを示します。

### 9.2.1. スコープと名前空間の例

これは、さまざまなスコープと名前空間を参照する方法、そして `global` と `nonlocal` が変数の束縛にどのように影響するかを示す例です。

```python
def scope_test():
    def do_local():
        spam = "local spam"

    def do_nonlocal():
        nonlocal spam
        spam = "nonlocal spam"

    def do_global():
        global spam
        spam = "global spam"

    spam = "test spam"
    do_local()
    print("After local assignment:", spam)
    do_nonlocal()
    print("After nonlocal assignment:", spam)
    do_global()
    print("After global assignment:", spam)

scope_test()
print("In global scope:", spam)
```

このコード例の出力は次のようになります。

```
After local assignment: test spam
After nonlocal assignment: nonlocal spam
After global assignment: nonlocal spam
In global scope: global spam
```

ローカルな代入（デフォルトの動作）が `scope_test` の `spam` の束縛を変更しなかったことに注目してください。`nonlocal` の代入は `scope_test` の `spam` の束縛を変更し、`global` の代入はモジュールレベルの束縛を変更しました。

また、`global` の代入の前に `spam` に事前の束縛がなかったこともわかります。

## 9.3. クラス初見

クラスは、少しの新しい構文、3つの新しいオブジェクト型、そしていくつかの新しいセマンティクスを導入します。

### 9.3.1. クラス定義の構文

最も単純な形式のクラス定義は次のようになります。

```python
class ClassName:
    <statement-1>
    .
    .
    .
    <statement-N>
```

クラス定義は、関数定義（`def`文）と同様に、効果を発揮する前に実行されなければなりません。（`if`文の分岐や関数の中にクラス定義を置くことも考えられます。）

実際には、クラス定義内の文は通常は関数定義ですが、他の文も許可されており、時には便利です（これについては後で触れます）。クラス内の関数定義は、通常、メソッドの呼び出し規約によって定められた特殊な形式の引数リストを持ちます。これも後で説明します。

クラス定義に入ると、新しい名前空間が作成され、それがローカルスコープとして使用されます。したがって、ローカル変数へのすべての代入はこの新しい名前空間に行われます。特に、関数定義は新しい関数の名前をここに束縛します。

クラス定義が（末尾まで到達して）正常に終了すると、**クラスオブジェクト**が作成されます。これは基本的に、クラス定義によって作成された名前空間の内容を包むラッパーです。クラスオブジェクトについては次のセクションで詳しく学びます。元のローカルスコープ（クラス定義に入る直前に有効だったもの）が復元され、クラスオブジェクトはここでクラス定義ヘッダで与えられたクラス名（例では `ClassName`）に束縛されます。

### 9.3.2. クラスオブジェクト

クラスオブジェクトは、**属性参照**と**インスタンス化**という2種類の操作をサポートします。

**属性参照**は、Pythonのすべての属性参照で使われる標準的な構文 `obj.name` を使います。有効な属性名は、クラスオブジェクトが作成されたときにクラスの名前空間にあったすべての名前です。したがって、クラス定義が次のようであれば、

```python
class MyClass:
    """A simple example class"""
    i = 12345

    def f(self):
        return 'hello world'
```

`MyClass.i` と `MyClass.f` は有効な属性参照であり、それぞれ整数と関数オブジェクトを返します。クラス属性には代入も可能なので、`MyClass.i` の値は代入によって変更できます。`__doc__` も有効な属性で、クラスに属するドキュメンテーション文字列 `"A simple example class"` を返します。

**クラスのインスタンス化**は、関数のような記法を使います。クラスオブジェクトが、クラスの新しいインスタンスを返す引数なしの関数であるかのように考えてください。例えば（上記のクラスを仮定して）、

```python
x = MyClass()
```

は、クラスの新しいインスタンスを作成し、このオブジェクトをローカル変数 `x` に代入します。

インスタンス化の操作（クラスオブジェクトを「呼び出す」こと）は、空のオブジェクトを作成します。多くのクラスでは、特定の初期状態にカスタマイズされたインスタンスを持つオブジェクトを作成したいと考えます。そのため、クラスは `__init__()` という名前の特別なメソッドを定義することができます。

```python
def __init__(self):
    self.data = []
```

クラスが `__init__()` メソッドを定義すると、クラスのインスタンス化は新しく作成されたクラスインスタンスに対して自動的に `__init__()` を呼び出します。したがって、この例では、新しく初期化されたインスタンスは次のようにして得られます。

```python
x = MyClass()```

もちろん、`__init__()` メソッドはより柔軟性を持たせるために引数を取ることができます。その場合、クラスインスタンス化演算子に与えられた引数は `__init__()` に渡されます。例えば、

```python
>>> class Complex:
...     def __init__(self, realpart, imagpart):
...         self.r = realpart
...         self.i = imagpart
...
>>> x = Complex(3.0, -4.5)
>>> x.r, x.i
(3.0, -4.5)
```

### 9.3.3. インスタンスオブジェクト

では、インスタンスオブジェクトで何ができるでしょうか？ インスタンスオブジェクトが理解する唯一の操作は**属性参照**です。有効な属性名には、**データ属性**と**メソッド**の2種類があります。

**データ属性**は、Smalltalkの「インスタンス変数」やC++の「データメンバ」に相当します。データ属性は宣言する必要がありません。ローカル変数と同様に、最初に代入されたときに生成されます。例えば、`x` が上で作成された `MyClass` のインスタンスである場合、次のコードは値 `16` を出力し、痕跡を残しません。

```python
x.counter = 1
while x.counter < 10:
    x.counter = x.counter * 2
print(x.counter)
del x.counter
```

もう一方のインスタンス属性参照は**メソッド**です。メソッドとは、オブジェクトに「属する」関数です。（Pythonでは、「メソッド」という用語はクラスインスタンスに限定されません。他のオブジェクト型もメソッドを持つことができます。例えば、リストオブジェクトには `append`, `insert`, `remove`, `sort` などのメソッドがあります。しかし、以下の説明では、特に断らない限り、クラスインスタンスオブジェクトのメソッドを指す言葉として「メソッド」を使用します。）

インスタンスオブジェクトの有効なメソッド名は、そのクラスに依存します。定義上、クラスの属性のうち関数オブジェクトであるものはすべて、そのインスタンスに対応するメソッドを定義します。したがって、私たちの例では、`MyClass.f` は関数なので `x.f` は有効なメソッド参照ですが、`MyClass.i` はそうではないので `x.i` はメソッドではありません。しかし、`x.f` は `MyClass.f` と同じものではありません。それは**メソッドオブジェクト**であり、関数オブジェクトではありません。

### 9.3.4. メソッドオブジェクト

通常、メソッドは束縛された直後に呼び出されます。

```python
x.f()
```

`MyClass` の例では、これは文字列 `'hello world'` を返します。しかし、メソッドをすぐに呼び出す必要はありません。`x.f` はメソッドオブジェクトであり、保存しておいて後で呼び出すことができます。例えば、

```python
xf = x.f
while True:
    print(xf())
```

は、`hello world` を延々と表示し続けます。

メソッドが呼び出されると、正確には何が起こるのでしょうか？ `f()` の関数定義には引数が指定されていたにもかかわらず、上記の `x.f()` が引数なしで呼び出されたことに気づいたかもしれません。引数はどうなったのでしょうか？ 引数を必要とする関数が引数なしで呼び出された場合、たとえその引数が実際には使われなくても、Pythonは例外を発生させるはずです…

実は、あなたはその答えを推測しているかもしれません。メソッドの特別な点は、**インスタンスオブジェクトが関数の第一引数として渡される**ことです。私たちの例では、`x.f()` の呼び出しは `MyClass.f(x)` と全く同じです。一般的に、`n`個の引数リストでメソッドを呼び出すことは、メソッドのインスタンスオブジェクトを第一引数の前に挿入して作成された引数リストで、対応する関数を呼び出すことと同じです。

メソッドがどのように機能するかまだ理解できない場合は、実装を見ると明確になるかもしれません。インスタンスの非データ属性が参照されると、インスタンスのクラスが検索されます。もしその名前が有効なクラス属性であり、それが関数オブジェクトであれば、インスタンスオブジェクトと見つかった関数オブジェクトを（ポインタで）抽象オブジェクトにまとめることでメソッドオブジェクトが作成されます。これがメソッドオブジェクトです。メソッドオブジェクトが引数リストと共に呼び出されると、インスタンスオブジェクトと引数リストから新しい引数リストが構築され、関数オブジェクトがこの新しい引数リストで呼び出されます。

### 9.3.5. クラス変数とインスタンス変数

一般的に言って、**インスタンス変数**は各インスタンスに固有のデータ用であり、**クラス変数**はクラスのすべてのインスタンスで共有される属性とメソッド用です。

```python
class Dog:

    kind = 'canine'         # 全てのインスタンスで共有されるクラス変数

    def __init__(self, name):
        self.name = name    # 各インスタンスに固有のインスタンス変数

>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>> d.kind                  # 全ての犬で共有
'canine'
>>> e.kind                  # 全ての犬で共有
'canine'
>>> d.name                  # dに固有
'Fido'
>>> e.name                  # eに固有
'Buddy'
```

「名前とオブジェクトについて」で議論したように、共有データはリストや辞書のようなミュータブルなオブジェクトが関わる場合、予期せぬ効果をもたらす可能性があります。例えば、以下のコードの `tricks` リストは、単一のリストが全ての `Dog` インスタンスで共有されてしまうため、クラス変数として使用すべきではありません。

```python
class Dog:

    tricks = []             # クラス変数の誤った使い方

    def __init__(self, name):
        self.name = name

    def add_trick(self, trick):
        self.tricks.append(trick)

>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>> d.add_trick('roll over')
>>> e.add_trick('play dead')
>>> d.tricks                # 予期せず全ての犬で共有される
['roll over', 'play dead']
```

クラスの正しい設計では、代わりにインスタンス変数を使用すべきです。

```python
class Dog:

    def __init__(self, name):
        self.name = name
        self.tricks = []    # 犬ごとに新しい空のリストを作成する

    def add_trick(self, trick):
        self.tricks.append(trick)

>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>> d.add_trick('roll over')
>>> e.add_trick('play dead')
>>> d.tricks
['roll over']
>>> e.tricks
['play dead']
```

## 9.4. 補足

インスタンスとクラスの両方に同じ属性名が存在する場合、属性の検索はインスタンスを優先します。

```python
>>> class Warehouse:
...     purpose = 'storage'
...     region = 'west'
...
>>> w1 = Warehouse()
>>> print(w1.purpose, w1.region)
storage west
>>> w2 = Warehouse()
>>> w2.region = 'east'
>>> print(w2.purpose, w2.region)
storage east
```

データ属性は、オブジェクトの通常の利用者（「クライアント」）だけでなく、メソッドからも参照されることがあります。言い換えれば、クラスは純粋な抽象データ型を実装するためには使えません。実際、Pythonにはデータ隠蔽を強制するものは何もありません。すべては慣習に基づいています。（一方で、Cで書かれたPython実装は、実装の詳細を完全に隠蔽し、オブジェクトへのアクセスを制御することができます。これはCで書かれたPythonの拡張機能で利用できます。）

クライアントはデータ属性を注意して使用すべきです。クライアントがメソッドによって維持されている不変条件を、データ属性を上書きすることで台無しにしてしまう可能性があります。クライアントは、名前の衝突を避ける限り、メソッドの有効性に影響を与えることなく、インスタンスオブジェクトに独自のデータ属性を追加できることに注意してください。ここでも、命名規則が多くの頭痛の種を救うことができます。

メソッド内からデータ属性（や他のメソッド！）を参照するための短縮形はありません。私は、これが実際にはメソッドの可読性を高めていると感じます。メソッドをざっと見るときに、ローカル変数とインスタンス変数を混同する可能性がありません。

多くの場合、メソッドの第一引数は `self` と呼ばれます。これは慣習にすぎません。`self` という名前はPythonにとって特別な意味を全く持ちません。ただし、この慣習に従わないと、あなたのコードは他のPythonプログラマにとって読みにくくなる可能性があり、また、そのような慣習に依存するクラスブラウザプログラムが書かれる可能性も考えられます。

クラス属性である関数オブジェクトは、そのクラスのインスタンスのメソッドを定義します。関数定義がクラス定義のテキスト内に含まれている必要はありません。クラス内のローカル変数に関数オブジェクトを代入することも問題ありません。例えば、

```python
# クラスの外で定義された関数
def f1(self, x, y):
    return min(x, x+y)

class C:
    f = f1

    def g(self):
        return 'hello world'

    h = g
```

今、`f`, `g`, `h` はすべてクラス `C` の属性であり、関数オブジェクトを参照しているため、結果としてすべて `C` のインスタンスのメソッドとなります（`h` は `g` と全く同じです）。このやり方は通常、プログラムの読者を混乱させるだけであることに注意してください。

メソッドは、`self` 引数のメソッド属性を使って他のメソッドを呼び出すことができます。

```python
class Bag:
    def __init__(self):
        self.data = []

    def add(self, x):
        self.data.append(x)

    def addtwice(self, x):
        self.add(x)
        self.add(x)
```

メソッドは、通常の関数と同じようにグローバル名を参照できます。メソッドに関連付けられたグローバルスコープは、その定義を含むモジュールです。（クラスがグローバルスコープとして使われることはありません。）メソッドでグローバルデータを使う正当な理由に遭遇することはめったにありませんが、グローバルスコープには多くの正当な用途があります。例えば、グローバルスコープにインポートされた関数やモジュールは、メソッドから利用できますし、そこで定義された関数やクラスも同様です。通常、メソッドを含むクラス自体がこのグローバルスコープで定義されており、次のセクションでは、メソッドが自身のクラスを参照したいと思うかもしれないいくつかの良い理由を見つけます。

各値はオブジェクトであり、したがってクラス（その **型** とも呼ばれる）を持ちます。これは `object.__class__` として保存されています。

## 9.5. 継承

もちろん、言語の機能が「クラス」という名に値するためには、継承をサポートしていなければなりません。派生クラス定義の構文は次のようになります。

```python
class DerivedClassName(BaseClassName):
    <statement-1>
    .
    .
    .
    <statement-N>
```

名前 `BaseClassName` は、派生クラス定義を含むスコープで定義されていなければなりません。基底クラス名の代わりに、他の任意の式も許可されます。これは、例えば基底クラスが別のモジュールで定義されている場合に便利です。

```python
class DerivedClassName(modname.BaseClassName):
```

派生クラス定義の実行は、基底クラスの場合と同じように進行します。クラスオブジェクトが構築されると、基底クラスが記憶されます。これは属性参照を解決するために使用されます。要求された属性がクラスに見つからない場合、検索は基底クラスに進みます。基底クラス自体が他のクラスから派生している場合、このルールは再帰的に適用されます。

派生クラスのインスタンス化には特別なことは何もありません。`DerivedClassName()` はクラスの新しいインスタンスを作成します。メソッド参照は次のように解決されます。対応するクラス属性が検索され、必要であれば基底クラスの連鎖をたどり、その結果が関数オブジェクトであればメソッド参照は有効です。

派生クラスは、基底クラスのメソッドをオーバーライド（override）することができます。メソッドは同じオブジェクトの他のメソッドを呼び出す際に特別な権限を持たないため、同じ基底クラスで定義された別のメソッドを呼び出す基底クラスのメソッドが、結果的にそれをオーバーライドする派生クラスのメソッドを呼び出すことがあります。（C++プログラマ向け：Pythonのすべてのメソッドは事実上 `virtual` です。）

派生クラスのオーバーライドメソッドは、実際には同じ名前の基底クラスのメソッドを単に置き換えるのではなく、拡張したい場合があります。基底クラスのメソッドを直接呼び出す簡単な方法があります。`BaseClassName.methodname(self, arguments)` と呼び出すだけです。これはクライアントにとっても時々便利です。（これは、基底クラスがグローバルスコープで `BaseClassName` としてアクセス可能な場合にのみ機能することに注意してください。）

Pythonには継承と共に機能する2つの組み込み関数があります。

-   インスタンスの型をチェックするには `isinstance()` を使います。`isinstance(obj, int)` は、`obj.__class__` が `int` または `int` から派生したクラスである場合にのみ `True` になります。
-   クラスの継承をチェックするには `issubclass()` を使います。`bool` は `int` のサブクラスなので `issubclass(bool, int)` は `True` です。しかし、`float` は `int` のサブクラスではないので `issubclass(float, int)` は `False` です。

### 9.5.1. 多重継承

Pythonは多重継承の一形態もサポートしています。複数の基底クラスを持つクラス定義は次のようになります。

```python
class DerivedClassName(Base1, Base2, Base3):
    <statement-1>
    .
    .
    .
    <statement-N>
```

ほとんどの目的において、最も単純なケースでは、親クラスから継承された属性の検索は、深さ優先、左から右へ行われ、階層に重複がある場合でも同じクラスを二度検索しない、と考えることができます。したがって、属性が `DerivedClassName` に見つからない場合、`Base1` で検索され、次に（再帰的に）`Base1` の基底クラスで検索され、それでも見つからなければ `Base2` で検索され、以下同様に続きます。

実際には、それはもう少し複雑です。メソッド解決順序（Method Resolution Order, MRO）は、`super()` への協調的な呼び出しをサポートするために動的に変化します。このアプローチは、他のいくつかの多重継承言語では `call-next-method` として知られており、単一継承言語に見られる `super` 呼び出しよりも強力です。

動的な順序付けが必要なのは、多重継承のすべてのケースが1つまたは複数の菱形関係（diamond relationships）を示すためです（少なくとも1つの親クラスに、最下層のクラスから複数のパスでアクセスできる場合）。例えば、すべてのクラスは `object` から継承するため、どんな多重継承のケースでも `object` に到達するための複数のパスが存在します。基底クラスが複数回アクセスされるのを防ぐために、動的アルゴリズムは検索順序を線形化します。この線形化は、各クラスで指定された左から右への順序を維持し、各親を一度だけ呼び出し、かつ単調（monotonic）であるように行われます（つまり、クラスをサブクラス化しても、その親の優先順位に影響を与えない）。これらの特性を総合すると、信頼性が高く拡張可能な多重継承クラスを設計することが可能になります。詳細は https://www.python.org/download/releases/2.3/mro/ を参照してください。

## 9.6. プライベート変数

オブジェクトの内部からしかアクセスできない「プライベート」なインスタンス変数は、Pythonには存在しません。しかし、ほとんどのPythonコードで従われている慣習があります。アンダースコアで始まる名前（例： `_spam`）は、APIの非公開部分（関数、メソッド、データメンバのいずれであれ）として扱うべきです。それは実装の詳細と見なされ、予告なく変更される可能性があります。

クラスプライベートなメンバには正当なユースケースがあるため（つまり、サブクラスで定義された名前との名前の衝突を避けるため）、**名前マングリング（name mangling）** と呼ばれるメカニズムが限定的にサポートされています。`__spam` という形式の識別子（少なくとも2つの先頭アンダースコア、最大で1つの末尾アンダースコア）は、テキスト的に `_classname__spam` に置き換えられます。ここで `classname` は、先頭のアンダースコアを除いた現在のクラス名です。このマングリングは、識別子がクラスの定義内に現れる限り、その構文上の位置に関係なく行われます。

名前マングリングは、サブクラスがクラス内メソッド呼び出しを壊すことなくメソッドをオーバーライドするのに役立ちます。例えば、

```python
class Mapping:
    def __init__(self, iterable):
        self.items_list = []
        self.__update(iterable)

    def update(self, iterable):
        for item in iterable:
            self.items_list.append(item)

    __update = update   # 元の update() メソッドのプライベートコピー

class MappingSubclass(Mapping):

    def update(self, keys, values):
        # update() のための新しいシグネチャを提供
        # しかし __init__() を壊さない
        for item in zip(keys, values):
            self.items_list.append(item)
```

上記の例は、`MappingSubclass` が `__update` 識別子を導入したとしても機能します。なぜなら、それは `Mapping` クラスでは `_Mapping__update` に、`MappingSubclass` クラスでは `_MappingSubclass__update` にそれぞれ置き換えられるからです。

マングリングのルールは主に事故を避けるために設計されていることに注意してください。プライベートと見なされる変数にアクセスしたり変更したりすることは依然として可能です。これは、デバッガなどの特殊な状況では便利でさえあります。

`exec()` や `eval()` に渡されたコードは、呼び出し元クラスのクラス名を現在のクラスとは見なさないことに注意してください。これは `global` 文の効果に似ており、その効果も同様にバイトコンパイルされたコードに限定されます。同じ制限は `getattr()`、`setattr()`、`delattr()` にも、また `__dict__` を直接参照する場合にも適用されます。

## 9.7. その他いろいろ

Pascalの「レコード」やCの「構造体」に似た、いくつかの名前付きデータ項目をまとめるデータ型が便利なことがあります。空のクラス定義がうまく機能します。

```python
class Employee:
    pass

john = Employee()  # 空の従業員レコードを作成

# レコードのフィールドを埋める
john.name = 'John Doe'
john.dept = 'computer lab'
john.salary = 1000
```

特定の抽象データ型を期待するPythonコードの一部には、そのデータ型のメソッドをエミュレートするクラスを渡すことがしばしば可能です。例えば、ファイルオブジェクトからデータをフォーマットする関数がある場合、代わりに文字列バッファからデータを取得する `read()` と `readline()` メソッドを持つクラスを定義し、それを引数として渡すことができます。

インスタンスメソッドオブジェクトも属性を持ちます。`m.__self__` はメソッド `m()` を持つインスタンスオブジェクトであり、`m.__func__` はそのメソッドに対応する関数オブジェクトです。

## 9.8. イテレータ

これまでに、ほとんどのコンテナオブジェクトが `for` 文を使ってループ処理できることにお気づきでしょう。

```python
for element in:
    print(element)
for element in (1, 2, 3):
    print(element)
for key in {'one':1, 'two':2}:
    print(key)
for char in "123":
    print(char)
for line in open("myfile.txt"):
    print(line, end='')
```

このアクセススタイルは、明確で、簡潔で、便利です。イテレータの使用はPython全体に浸透し、統一感をもたらしています。舞台裏では、`for` 文はコンテナオブジェクトに対して `iter()` を呼び出します。この関数は、コンテナ内の要素に一度に一つずつアクセスする `__next__()` メソッドを定義した**イテレータオブジェクト**を返します。要素がなくなると、`__next__()` は `StopIteration` 例外を発生させ、`for` ループに終了を伝えます。`__next__()` メソッドは組み込み関数 `next()` を使って呼び出すことができます。この例は、その仕組み全体を示しています。

```python
>>> s = 'abc'
>>> it = iter(s)
>>> it
<str_iterator object at 0x10c90e650>
>>> next(it)
'a'
>>> next(it)
'b'
>>> next(it)
'c'
>>> next(it)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
    next(it)
StopIteration
```

イテレータプロトコルの裏側にある仕組みを見たので、自分のクラスにイテレータの振る舞いを追加するのは簡単です。`__next__()` メソッドを持つオブジェクトを返す `__iter__()` メソッドを定義します。もしクラスが `__next__()` を定義するなら、`__iter__()` は単に `self` を返すことができます。

```python
class Reverse:
    """シーケンスを逆順にループするためのイテレータ"""
    def __init__(self, data):
        self.data = data
        self.index = len(data)

    def __iter__(self):
        return self

    def __next__(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.data[self.index]

>>> rev = Reverse('spam')
>>> iter(rev)
<__main__.Reverse object at 0x00A1DB50>
>>> for char in rev:
...     print(char)
...
m
a
p
s
```

## 9.9. ジェネレータ

**ジェネレータ**は、イテレータを作成するためのシンプルで強力なツールです。通常の関数のように書かれますが、データを返したいときはいつでも `yield` 文を使います。ジェネレータに対して `next()` が呼び出されるたびに、ジェネレータは中断したところから再開します（すべてのデータ値と最後に実行された文を記憶しています）。例を見れば、ジェネレータがいかに簡単に作成できるかがわかります。

```python
def reverse(data):
    for index in range(len(data)-1, -1, -1):
        yield data[index]

>>> for char in reverse('golf'):
...     print(char)
...
f
l
o
g
```

ジェネレータでできることはすべて、前のセクションで説明したクラスベースのイテレータでも実現できます。ジェネレータを非常にコンパクトにしているのは、`__iter__()` と `__next__()` メソッドが自動的に作成される点です。

もう一つの重要な特徴は、ローカル変数と実行状態が呼び出し間で自動的に保存されることです。これにより、`self.index` や `self.data` のようなインスタンス変数を使うアプローチよりも、関数が書きやすく、はるかに明確になります。

メソッドの自動作成とプログラム状態の保存に加えて、ジェネレータが終了すると、自動的に `StopIteration` を発生させます。これらの特徴が組み合わさることで、通常の関数を書くのと変わらない手間で簡単にイテレータを作成できます。

## 9.10. ジェネレータ式

いくつかの単純なジェネレータは、リスト内包表記に似た構文を使い、角括弧の代わりに丸括弧を用いることで、式として簡潔に記述できます。これらの式は、ジェネレータがそれを囲む関数によってすぐに使用される状況のために設計されています。ジェネレータ式は、完全なジェネレータ定義よりもコンパクトですが汎用性は低く、同等のリスト内包表記よりもメモリに優しい傾向があります。

例：

```python
>>> sum(i*i for i in range(10))                 # 平方の和
285

>>> xvec =
>>> yvec =
>>> sum(x*y for x,y in zip(xvec, yvec))         # 内積
260

>>> unique_words = set(word for line in page for word in line.split())

>>> valedictorian = max((student.gpa, student.name) for student in graduates)

>>> data = 'golf'
>>> list(data[i] for i in range(len(data)-1, -1, -1))
['f', 'l', 'o', 'g']
```

---
**脚注**

¹
一つだけ例外があります。モジュールオブジェクトは `__dict__` という秘密の読み取り専用属性を持っており、これはモジュールの名前空間を実装するために使用される辞書を返します。名前 `__dict__` は属性ですが、グローバル名ではありません。明らかに、これを使用することは名前空間実装の抽象化を侵害するものであり、事後デバッガのようなものに限定されるべきです。
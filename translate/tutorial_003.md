<!-- translate/tutorial_003.md -->

## 3. Pythonの簡単な紹介

これからの例では、入力と出力はプロンプト（`>>>` と `...`）があるかないかで区別します。例を試すには、プロンプトが表示された後に続く部分をすべて入力してください。プロンプトで始まっていない行は、インタプリタからの出力です。例の途中で `...` だけの行が出てきたら、それは空行を入力するという意味です。これは複数行にわたるコマンドの終わりを伝えるために使います。

> **ヒント:** 例の右上にある `>>>` をクリックすると、プロンプトと出力の表示を切り替えられます。プロンプトと出力を非表示にすれば、入力行を簡単にコピーして自分のインタプリタに貼り付けられます。

このマニュアルの多くの例では、対話プロンプトで入力するものであっても、コメントが含まれています。Pythonのコメントはハッシュ文字（`#`）で始まり、その行の終わりまで続きます。コメントは行の先頭にも、空白やコードの後にも書けますが、文字列リテラル（クォートで囲まれた文字列）の中には書けません。文字列リテラルの中にあるハッシュ文字は、ただのハッシュ文字です。コメントはコードを分かりやすくするためのもので、Pythonには解釈されないので、例を入力する際には省略しても構いません。

いくつか例を見てみましょう。

```python
# これが最初のコメント
spam = 1  # そしてこれが2番目のコメント
          # ...さらに3番目！
text = "# これはコメントではありません。クォートの中にあるからです。"
```

### 3.1. Pythonを電卓として使ってみよう

いくつか簡単なPythonのコマンドを試してみましょう。インタプリタを起動して、プライマリプロンプト `>>>` が表示されるのを待ってください。（すぐに表示されるはずです。）

#### 3.1.1. 数値

インタプリタは簡単な電卓のように動作します。式を入力すれば、その値を表示してくれます。式の構文は直感的です。演算子 `+`, `-`, `*`, `/` は、他の多くの言語（例えばPascalやC言語）と同じように機能します。グループ化には丸括弧 `()` を使えます。例えば、次のようになります。

```python
>>> 2 + 2
4
>>> 50 - 5*6
20
>>> (50 - 5*6) / 4
5.0
>>> 8 / 5  # 割り算は常に浮動小数点数を返す
1.6
```

整数（例: `2`, `4`, `20`）は `int` 型、小数部分を持つ数（例: `5.0`, `1.6`）は `float` 型です。数値の型については、このチュートリアルの後半でさらに詳しく見ていきます。

割り算 (`/`) は常に `float` を返します。小数点以下を切り捨てて整数の結果を得る「整数除算」をしたい場合は `//` 演算子を使います。余りを計算したい場合は `%` を使います。

```python
>>> 17 / 3  # 通常の割り算はfloatを返す
5.666666666666667
>>>
>>> 17 // 3  # 整数除算は小数部分を切り捨てる
5
>>> 17 % 3   # % 演算子は割り算の余りを返す
2
>>> 5 * 3 + 2  # (整数除算の商 * 除数) + 余り
17
```

Pythonでは、`**` 演算子を使ってべき乗を計算できます¹。

```python
>>> 5 ** 2  # 5の2乗
25
>>> 2 ** 7  # 2の7乗
128
```

等号 (`=`) は、変数に値を代入するために使います。代入が行われた後は、次のプロンプトが表示されるまで何も表示されません。

```python
>>> width = 20
>>> height = 5 * 9
>>> width * height
900
```

変数が「定義」（値が代入）されていないのに使おうとすると、エラーになります。

```python
>>> n  # 未定義の変数にアクセスしようとする
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'n' is not defined
```

浮動小数点数も完全にサポートされています。型の異なるオペランド（整数と浮動小数点数）が混在する演算では、整数のオペランドは浮動小数点数に変換されます。

```python
>>> 4 * 3.75 - 1
14.0
```

対話モードでは、最後に出力された式の値が、変数 `_` （アンダースコア）に代入されます。これを使えば、Pythonを電卓として使うときに、計算を続けるのが少し楽になります。

```python
>>> tax = 12.5 / 100
>>> price = 100.50
>>> price * tax
12.5625
>>> price + _
113.0625
>>> round(_, 2)
113.06
```

この変数は、ユーザーからは読み取り専用として扱うべきです。明示的に値を代入しないでください。もし代入してしまうと、この魔法の振る舞いを持つ組み込み変数を隠してしまう、同じ名前の独立したローカル変数を作成することになります。

`int` と `float` に加えて、Pythonは `Decimal` や `Fraction` といった他の数値型もサポートしています。また、複素数も組み込みでサポートしており、虚数部を示すために `j` または `J` を接尾辞として使います（例: `3+5j`）。

#### 3.1.2. 文字列

Pythonは数値だけでなく、文字列も扱うことができます。文字列はいくつかの方法で表現できます。シングルクォート (`'...'`) またはダブルクォート (`"..."`) で囲むことができ、どちらも同じ結果になります²。`\` はクォートをエスケープ（特別な意味を打ち消す）するために使えます。

```python
>>> 'spam eggs'  # シングルクォート
'spam eggs'
>>> 'doesn\'t'  # \' でシングルクォートをエスケープ
"doesn't"
>>> "doesn't"  # ...あるいは代わりにダブルクォートを使う
"doesn't"
>>> '"Yes," they said.'
'"Yes," they said.'
>>> "\"Yes,\" they said."
'"Yes," they said.'
>>> '"Isn\'t," they said.'
'"Isn\'t," they said.'
```

対話インタプリタでは、出力される文字列はクォートで囲まれ、特殊文字はバックスラッシュでエスケープされます。これは入力と見た目が異なる場合がありますが（囲むクォートが変わるなど）、2つの文字列は同じものです。文字列にシングルクォートが含まれていてダブルクォートが含まれていない場合はダブルクォートで囲まれ、それ以外の場合はシングルクォートで囲まれます。`print()` 関数を使うと、囲みクォートを省略し、エスケープ文字や特殊文字を解釈して表示するため、より読みやすい出力が得られます。

```python
>>> '"Isn\'t," they said.'
'"Isn\'t," they said.'
>>> print('"Isn\'t," they said.')
"Isn't," they said.
>>> s = 'First line.\nSecond line.'  # \n は改行を意味する
>>> s  # print() なしだと \n がそのまま出力に含まれる
'First line.\nSecond line.'
>>> print(s)  # print() ありだと \n が改行を生成する
First line.
Second line.
```

`\` で始まる文字を特殊文字として解釈されたくない場合は、最初のクォートの前に `r` を付けて「raw文字列」を使うことができます。

```python
>>> print('C:\some\name')  # ここでは \n が改行として解釈されてしまう
C:\some
ame
>>> print(r'C:\some\name')  # クォートの前の r に注目
C:\some\name
```

文字列リテラルは複数行にまたがることができます。一つの方法は、三重クォート `"""..."""` または `'''...'''` を使うことです。行末の改行は自動的に文字列に含まれますが、行末に `\` を追加することでこれを防ぐことも可能です。次の例を見てみましょう。

```python
print("""\
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
""")
```

これは次のような出力を生成します（最初の改行が含まれていない点に注意してください）。

```
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
```

文字列は `+` 演算子で連結（くっつける）でき、`*` 演算子で繰り返すことができます。

```python
>>> # 'un' を3回、その後に 'ium'
>>> 3 * 'un' + 'ium'
'unununium'
```

2つ以上の文字列リテラル（クォートで囲まれたもの）が隣り合っていると、自動的に連結されます。

```python
>>> 'Py' 'thon'
'Python'
```

この機能は、長い文字列を分割したいときに特に便利です。

```python
>>> text = ('Put several strings within parentheses '
...         'to have them joined together.')
>>> text
'Put several strings within parentheses to have them joined together.'
```

ただし、これは2つのリテラルでのみ機能し、変数や式では機能しません。

```python
>>> prefix = 'Py'
>>> prefix 'thon'  # 変数と文字列リテラルは連結できない
  File "<stdin>", line 1
    prefix 'thon'
                ^
SyntaxError: invalid syntax
>>> ('un' * 3) 'ium'
  File "<stdin>", line 1
    ('un' * 3) 'ium'
                   ^
SyntaxError: invalid syntax
```

変数を連結したい場合や、変数とリテラルを連結したい場合は、`+` を使ってください。

```python
>>> prefix + 'thon'
'Python'
```

文字列はインデックス（添え字）を指定して、特定の位置の文字を取り出すことができます。最初の文字のインデックスは `0` です。Pythonには独立した文字型はなく、文字は単にサイズが1の文字列です。

```python
>>> word = 'Python'
>>> word  # 0番目の文字
'P'
>>> word  # 5番目の文字
'n'
```

インデックスには負の数を指定することもでき、その場合は右から数え始めます。

```python
>>> word[-1]  # 最後の文字
'n'
>>> word[-2]  # 最後から2番目の文字
'o'
>>> word[-6]
'P'
```

`-0` は `0` と同じなので、負のインデックスは `-1` から始まることに注意してください。

インデックス指定に加えて、スライスもサポートされています。インデックス指定が個々の文字を取得するために使われるのに対し、スライスは部分文字列を取得することができます。

```python
>>> word[0:2]  # 0番目から (含まれる) 2番目まで (含まれない)
'Py'
>>> word[2:5]  # 2番目から (含まれる) 5番目まで (含まれない)
'tho'
```

スライスのインデックスには便利なデフォルト値があります。最初のインデックスを省略すると `0` とみなされ、2番目のインデックスを省略すると文字列のサイズとみなされます。

```python
>>> word[:2]   # 最初から2番目まで (含まれない)
'Py'
>>> word[4:]   # 4番目から (含まれる) 最後まで
'on'
>>> word[-2:]  # 最後から2番目 (含まれる) から最後まで
'on'
```

開始位置は常に含まれ、終了位置は常に含まれない点に注目してください。これにより、`s[:i] + s[i:]` は常に `s` と等しくなります。

```python
>>> word[:2] + word[2:]
'Python'
>>> word[:4] + word[4:]
'Python'
```

スライスの仕組みを覚える一つの方法は、インデックスが文字と文字の間を指していると考えることです。最初の文字の左端が `0` となります。そうすると、`n` 文字の文字列の最後の文字の右端はインデックス `n` になります。例えば、

```
 +---+---+---+---+---+---+
 | P | y | t | h | o | n |
 +---+---+---+---+---+---+
 0   1   2   3   4   5   6
-6  -5  -4  -3  -2  -1
```

上の段の数字は、文字列内のインデックス `0…6` の位置を示し、下の段は対応する負のインデックスを示します。`i` から `j` へのスライスは、それぞれ `i` と `j` のラベルが付いた境界の間のすべての文字で構成されます。

負でないインデックスの場合、両方が範囲内であれば、スライスの長さはインデックスの差になります。例えば、`word[1:3]` の長さは `2` です。

大きすぎるインデックスを使おうとするとエラーになります。

```python
>>> word  # この単語は6文字しかない
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: string index out of range
```

しかし、範囲外のスライスインデックスは、スライスで使われる際には適切に処理されます。

```python
>>> word[4:42]
'on'
>>> word[42:]
''
```

Pythonの文字列は変更できません — つまり「イミュータブル（immutable）」です。そのため、インデックスを指定した位置に代入しようとするとエラーになります。

```python
>>> word = 'J'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
>>> word[2:] = 'py'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
```

もし違う文字列が必要な場合は、新しい文字列を作成するべきです。

```python
>>> 'J' + word[1:]
'Jython'
>>> word[:2] + 'py'
'Pypy'
```

組み込み関数 `len()` は、文字列の長さを返します。

```python
>>> s = 'supercalifragilisticexpialidocious'
>>> len(s)
34
```

#### 3.1.3. リスト

Pythonには、他の値をグループ化するために使われる、いくつかの複合データ型があります。最も用途が広いのは「リスト」で、角括弧 `[]` の中にカンマ区切りの値（アイテム）を並べて書くことができます。リストは異なる型のアイテムを含むこともできますが、通常はすべてのアイテムが同じ型です。

```python
>>> squares =
>>> squares

```

文字列（および他のすべての組み込みシーケンス型）と同様に、リストもインデックス指定とスライスができます。

```python
>>> squares  # インデックス指定はアイテムを返す
1
>>> squares[-1]
25
>>> squares[-3:]  # スライスは新しいリストを返す

```

すべてのスライス操作は、要求された要素を含む新しいリストを返します。これは、次のスライスがリストの「浅いコピー（shallow copy）」を返すことを意味します。

```python
>>> squares[:]

```

リストは連結のような操作もサポートしています。

```python
>>> squares +

```

イミュータブル（不変）である文字列とは異なり、リストはミュータブル（mutable）な型です。つまり、その内容を変更することが可能です。

```python
>>> cubes =  # 何かおかしい
>>> 4 ** 3  # 4の3乗は64で、65ではない！
64
>>> cubes = 64  # 間違った値を置き換える
>>> cubes

```

`append()` メソッドを使って、リストの末尾に新しいアイテムを追加することもできます（メソッドについては後で詳しく学びます）。

```python
>>> cubes.append(216)  # 6の3乗を追加
>>> cubes.append(7 ** 3)  # そして7の3乗も追加
>>> cubes

```

スライスへの代入も可能で、これによりリストのサイズを変更したり、完全に空にしたりすることもできます。

```python
>>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
>>> letters
['a', 'b', 'c', 'd', 'e', 'f', 'g']
>>> # いくつかの値を置き換える
>>> letters[2:5] = ['C', 'D', 'E']
>>> letters
['a', 'b', 'C', 'D', 'E', 'f', 'g']
>>> # 今度はそれらを削除する
>>> letters[2:5] = []
>>> letters
['a', 'b', 'f', 'g']
>>> # すべての要素を空のリストで置き換えてリストを空にする
>>> letters[:] = []
>>> letters
[]
```

組み込み関数 `len()` はリストにも適用できます。

```python
>>> letters = ['a', 'b', 'c', 'd']
>>> len(letters)
4
```

リストを入れ子にすることも可能です（他のリストを含むリストを作成する）。例えば、

```python
>>> a = ['a', 'b', 'c']
>>> n =
>>> x = [a, n]
>>> x
[['a', 'b', 'c'],]
>>> x
['a', 'b', 'c']
>>> x
'b'
```

### 3.2. プログラミングへの第一歩

もちろん、Pythonを2足す2のような単純な作業以上に使うことができます。例えば、フィボナッチ数列の最初の部分を次のように書くことができます。

```python
>>> # フィボナッチ数列:
... # 2つの要素の和が次の要素を定義する
... a, b = 0, 1
>>> while a < 10:
...     print(a)
...     a, b = b, a+b
...
0
1
1
2
3
5
8
```

この例では、いくつかの新しい機能が導入されています。

*   最初の行には**多重代入**が含まれています。変数 `a` と `b` は、同時に新しい値 `0` と `1` を受け取ります。最後の行でもこれが再び使われており、右辺の式はすべて、いずれかの代入が行われる前に評価されることを示しています。右辺の式は左から右へと評価されます。

*   **`while` ループ**は、条件（ここでは `a < 10`）が真（true）である限り実行されます。Pythonでは、C言語と同様に、0以外の整数値は真とみなされ、0は偽（false）とみなされます。条件は文字列やリストの値、実際には任意のシーケンスでもかまいません。長さが0でないものは真、空のシーケンスは偽です。この例で使われているテストは単純な比較です。標準的な比較演算子はC言語と同じように書きます: `<` (より小さい), `>` (より大きい), `==` (等しい), `<=` (以下), `>=` (以上), `!=` (等しくない)。

*   ループの**本体はインデントされています**。インデントは、Pythonが文をグループ化する方法です。対話プロンプトでは、インデントされた各行に対してタブまたはスペースを入力する必要があります。実際には、テキストエディタを使ってより複雑な入力を準備することになりますが、まともなテキストエディタには自動インデント機能があります。複合文を対話的に入力する場合、完了を示すために空行を後に入力する必要があります（パーサーはいつ最後の行を入力したか推測できないためです）。基本的なブロック内の各行は、同じ量だけインデントする必要があることに注意してください。

*   **`print()` 関数**は、与えられた引数の値を書き出します。これは、複数の引数、浮動小数点数、文字列の扱い方において、単に書きたい式を書くこと（電卓の例で前にやったように）とは異なります。文字列はクォートなしで出力され、アイテムの間にはスペースが挿入されるので、このようにきれいにフォーマットすることができます。

    ```python
    >>> i = 256*256
    >>> print('The value of i is', i)
    The value of i is 65536
    ```

    キーワード引数 `end` を使うと、出力後の改行をなくしたり、出力を別の文字列で終わらせたりすることができます。

    ```python
    >>> a, b = 0, 1
    >>> while a < 1000:
    ...     print(a, end=',')
    ...     a, b = b, a+b
    ...
    0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,
    ```

---
**脚注**

<sup>1</sup> `**` は `-` よりも優先順位が高いため、`-3**2` は `-(3**2)` と解釈され、結果として `-9` になります。これを避けて `9` を得るには、`(-3)**2` を使います。

<sup>2</sup> 他の言語とは異なり、`\n` のような特殊文字は、シングルクォート (`'...'`) とダブルクォート (`"..."`) の両方で同じ意味を持ちます。2つの違いは、シングルクォート内では `"` をエスケープする必要がない（ただし `\'` はエスケープする必要がある）ということだけで、その逆もまた同様です。
<!-- translate/tutorial_006.md -->

## 6. モジュール

Pythonインタプリタを終了して再び起動すると、それまでに行った定義（関数や変数）は失われてしまいます。そのため、少し長めのプログラムを書きたい場合は、テキストエディタを使ってインタプリタへの入力を準備し、そのファイルを入力として実行する方が良いでしょう。これは**スクリプト**を作成する、として知られています。プログラムが長くなるにつれて、メンテナンスを容易にするために複数のファイルに分割したくなるかもしれません。また、自分で書いた便利な関数を、その定義を各プログラムにコピーすることなく、いくつかのプログラムで使いたくなるかもしれません。

これをサポートするために、Pythonには定義をファイルにまとめておき、スクリプトや対話モードのインタプリタからそれらを使用する方法があります。このようなファイルは**モジュール (module)** と呼ばれます。モジュールからの定義は、他のモジュールや**メインモジュール**（トップレベルで実行されるスクリプトや電卓モードでアクセスできる変数の集まり）に**インポート (import)** することができます。

モジュールは、Pythonの定義と文を含むファイルです。ファイル名がモジュール名に接尾辞 `.py` が付いたものになります。モジュール内では、そのモジュールの名前（文字列として）が、グローバル変数 `__name__` の値として利用できます。例えば、お気に入りのテキストエディタを使って、現在のディレクトリに `fibo.py` という名前のファイルを次の内容で作成してみてください。

```python
# フィボナッチ数列モジュール

def fib(n):    # n までのフィボナッチ数列を書き出す
    a, b = 0, 1
    while a < n:
        print(a, end=' ')
        a, b = b, a+b
    print()

def fib2(n):   # n までのフィボナッチ数列をリストで返す
    result = []
    a, b = 0, 1
    while a < n:
        result.append(a)
        a, b = b, a+b
    return result
```

さて、Pythonインタプリタを起動し、次のコマンドでこのモジュールをインポートします。

```python
>>> import fibo
```

これによって、`fibo` で定義された関数の名前が直接現在のシンボルテーブル（変数が管理されている場所）に入るわけではありません。そこにはモジュール名 `fibo` が入るだけです。モジュール名を使えば、関数にアクセスできます。

```python
>>> fibo.fib(1000)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
>>> fibo.fib2(100)

>>> fibo.__name__
'fibo'
```

ある関数を頻繁に使うつもりなら、ローカルな名前に代入することができます。

```python
>>> fib = fibo.fib
>>> fib(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377
```

### 6.1. モジュールについてもう少し

モジュールは、関数の定義だけでなく、実行可能な文を含むこともできます。これらの文は、モジュールを初期化するためのものです。これらは、`import` 文でモジュール名が初めて現れたときに**一度だけ**実行されます¹。（ファイルがスクリプトとして実行された場合にも実行されます。）

各モジュールは、独自のプライベートなシンボルテーブルを持っており、これはそのモジュールで定義されたすべての関数によってグローバルシンボルテーブルとして使われます。したがって、モジュールの作成者は、ユーザーのグローバル変数と偶然に衝突することを心配せずに、モジュール内でグローバル変数を使用できます。一方で、もしあなたが何をしているか分かっているなら、その関数を参照するのと同じ記法 `modname.itemname` を使って、モジュールのグローバル変数に触れることができます。

モジュールは他のモジュールをインポートできます。すべての `import` 文をモジュール（あるいはスクリプト）の先頭に置くのが慣習ですが、必須ではありません。インポートされたモジュール名は、インポートする側のモジュールのグローバルシンボルテーブルに置かれます。

`import` 文には、モジュールから名前を直接インポートする側のモジュールのシンボルテーブルに取り込む変種があります。例えば、

```python
>>> from fibo import fib, fib2
>>> fib(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377
```

これは、インポート元のモジュール名をローカルシンボルテーブルに導入しません（なので、この例では `fibo` は定義されていません）。

モジュールが定義するすべての名前をインポートする変種さえあります。

```python
>>> from fibo import *
>>> fib(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377
```

これは、アンダースコア (`_`) で始まる名前以外、すべての名前をインポートします。ほとんどの場合、Pythonプログラマはこの機能を使用しません。なぜなら、未知の名前の集合をインタプリタに導入し、すでに定義してあるものを隠してしまう可能性があるからです。

> **注意:** 一般的に、モジュールやパッケージから `*` をインポートするやり方は、コードが読みにくくなる原因となることが多いため、 frowned upon（好ましくない）とされています。ただし、対話セッションでタイピングを節約するためには使ってもよいでしょう。

モジュール名の後に `as` が続く場合、`as` の後の名前がインポートされたモジュールに直接束縛されます。

```python
>>> import fibo as fib
>>> fib.fib(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377
```
これは、`import fibo` をするのと同じ方法でモジュールを効果的にインポートしますが、唯一の違いは `fib` として利用できることです。

`from` を使う際にも同様の効果で利用できます。

```python
>>> from fibo import fib as fibonacci
>>> fibonacci(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377
```

> **注:** 効率上の理由から、各モジュールはインタプリタのセッションごとに一度しかインポートされません。したがって、モジュールを変更した場合は、インタプリタを再起動する必要があります。あるいは、対話的にテストしたいモジュールが1つだけの場合は、`importlib.reload()` を使用します。例: `import importlib; importlib.reload(modulename)`。

#### 6.1.1. モジュールをスクリプトとして実行する

Pythonモジュールを次のように実行すると、

```bash
python fibo.py <引数>
```

モジュール内のコードは、インポートされた場合と同じように実行されますが、`__name__` が `"__main__"` に設定されます。つまり、モジュールの末尾に次のコードを追加することで、

```python
if __name__ == "__main__":
    import sys
    fib(int(sys.argv))
```
そのファイルをインポート可能なモジュールとしてだけでなく、スクリプトとしても利用可能にすることができます。なぜなら、コマンドラインを解析するコードは、モジュールが「メイン」ファイルとして実行された場合にのみ実行されるからです。

```bash
$ python fibo.py 50
0 1 1 2 3 5 8 13 21 34```

モジュールがインポートされた場合、このコードは実行されません。

```python
>>> import fibo
>>>
```
これは、モジュールに便利なユーザーインターフェースを提供するため、またはテスト目的（モジュールをスクリプトとして実行するとテストスイートが実行される）でよく使われます。

#### 6.1.2. モジュールの検索パス

`spam` という名前のモジュールがインポートされると、インタプリタはまずその名前を持つ組み込みモジュールを探します。これらのモジュール名は `sys.builtin_module_names` にリストされています。見つからない場合、次に変数 `sys.path` で与えられるディレクトリのリストの中から `spam.py` という名前のファイルを探します。`sys.path` は次の場所から初期化されます。

*   入力スクリプトを含むディレクトリ（またはファイルが指定されていない場合は現在のディレクトリ）。
*   `PYTHONPATH`（シェル変数 `PATH` と同じ構文を持つディレクトリ名のリスト）。
*   インストール依存のデフォルト（慣習として `site-packages` ディレクトリを含み、`site` モジュールによって処理される）。

> **注:** シンボリックリンクをサポートするファイルシステムでは、入力スクリプトを含むディレクトリは、シンボリックリンクをたどった後に計算されます。言い換えれば、シンボリックリンクを含むディレクトリはモジュール検索パスに追加されません。

初期化後、Pythonプログラムは `sys.path` を変更できます。実行されているスクリプトを含むディレクトリは、標準ライブラリのパスよりも前に、検索パスの先頭に置かれます。これは、そのディレクトリ内のスクリプトが、ライブラリディレクトリ内の同名のモジュールの代わりにロードされることを意味します。意図した置き換えでない限り、これはエラーです。詳細は「標準モジュール」のセクションを参照してください。

#### 6.1.3. 「コンパイル済み」Pythonファイル

モジュールのロードを高速化するために、Pythonは各モジュールのコンパイル済みバージョンを `__pycache__` ディレクトリに `module.version.pyc` という名前でキャッシュします。ここで `version` はコンパイル済みファイルのフォーマットをエンコードし、通常はPythonのバージョン番号を含みます。例えば、CPythonリリース3.3では、`spam.py` のコンパイル済みバージョンは `__pycache__/spam.cpython-33.pyc` としてキャッシュされます。この命名規則により、異なるリリースや異なるバージョンのPythonからのコンパイル済みモジュールが共存できます。

Pythonは、ソースの変更日時をコンパイル済みバージョンと比較して、それが古くなっていて再コンパイルが必要かどうかをチェックします。これは完全に自動的なプロセスです。また、コンパイル済みモジュールはプラットフォームに依存しないので、同じライブラリを異なるアーキテクチャのシステム間で共有できます。

Pythonは2つの状況でキャッシュをチェックしません。第一に、コマンドラインから直接ロードされたモジュールについては、常に再コンパイルし、結果を保存しません。第二に、ソースモジュールがない場合はキャッシュをチェックしません。ソースなし（コンパイル済みのみ）の配布をサポートするには、コンパイル済みモジュールがソースディレクトリにあり、ソースモジュールがあってはなりません。

専門家向けのヒント：

*   Pythonコマンドの `-O` または `-OO` スイッチを使って、コンパイル済みモジュールのサイズを小さくすることができます。`-O` スイッチは `assert` 文を削除し、`-OO` スイッチは `assert` 文と `__doc__` 文字列の両方を削除します。プログラムによってはこれらが利用可能であることに依存している場合があるため、何をしているか分かっている場合にのみこのオプションを使用するべきです。「最適化された」モジュールは `opt-` タグを持ち、通常はより小さいです。将来のリリースでは最適化の効果が変わるかもしれません。
*   プログラムは `.pyc` ファイルから読み込まれたときも `.py` ファイルから読み込まれたときも、実行速度は速くなりません。`.pyc` ファイルが速いのは、それらがロードされる速度だけです。
*   `compileall` モジュールは、ディレクトリ内のすべてのモジュールの `.pyc` ファイルを作成できます。
*   このプロセスに関する詳細（決定のフローチャートを含む）は、PEP 3147にあります。

### 6.2. 標準モジュール

Pythonには標準モジュールのライブラリが付属しており、別のドキュメントであるPythonライブラリリファレンス（以下「ライブラリリファレンス」）で説明されています。いくつかのモジュールはインタプリタに組み込まれています。これらは、言語のコアの一部ではないが、効率のため、またはシステムコールなどのオペレーティングシステムのプリミティブへのアクセスを提供するために組み込まれている操作へのアクセスを提供します。そのようなモジュールのセットは、基盤となるプラットフォームにも依存する設定オプションです。例えば、`winreg` モジュールはWindowsシステムでのみ提供されます。特に注目すべきモジュールが1つあります。それは、すべてのPythonインタプリタに組み込まれている `sys` です。変数 `sys.ps1` と `sys.ps2` は、プライマリおよびセカンダリプロンプトとして使用される文字列を定義します。

```python
>>> import sys
>>> sys.ps1
'>>> '
>>> sys.ps2
'... '
>>> sys.ps1 = 'C> '
C> print('Yuck!')
Yuck!
C>
```

これら2つの変数は、インタプリタが対話モードにある場合にのみ定義されます。

変数 `sys.path` は、インタプリタのモジュール検索パスを決定する文字列のリストです。これは、環境変数 `PYTHONPATH` から取得したデフォルトパス、または `PYTHONPATH` が設定されていない場合は組み込みのデフォルトから初期化されます。標準的なリスト操作を使って変更できます。

```python
>>> import sys
>>> sys.path.append('/ufs/guido/lib/python')
```

### 6.3. `dir()` 関数

組み込み関数 `dir()` は、モジュールがどの名前を定義しているかを調べるために使われます。ソートされた文字列のリストを返します。

```python
>>> import fibo, sys
>>> dir(fibo)
['__name__', 'fib', 'fib2']
>>> dir(sys)  
['__breakpointhook__', '__displayhook__', '__doc__', '__excepthook__', ...]
```

引数なしで `dir()` を呼び出すと、現在定義している名前をリストアップします。

```python
>>> a =
>>> import fibo
>>> fib = fibo.fib
>>> dir()
['__builtins__', '__name__', 'a', 'fib', 'fibo', 'sys']
```

これは、変数、モジュール、関数など、すべての種類の名前をリストアップすることに注意してください。

`dir()` は、組み込み関数や変数の名前はリストアップしません。それらのリストが必要な場合は、標準モジュール `builtins` で定義されています。

```python
>>> import builtins
>>> dir(builtins)  
['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', ...]
```

### 6.4. パッケージ

パッケージは、「ドット付きモジュール名」を使ってPythonのモジュール名前空間を構造化する方法です。例えば、モジュール名 `A.B` は、`A` という名前のパッケージ内にある `B` という名前のサブモジュールを指定します。モジュールを使うことで、異なるモジュールの作成者がお互いのグローバル変数名を気にする必要がなくなるのと同様に、ドット付きモジュール名を使うことで、NumPyやPillowのような複数モジュールからなるパッケージの作成者が、お互いのモジュール名を気にする必要がなくなります。

音響ファイルと音響データを統一的に扱うためのモジュールのコレクション（「パッケージ」）を設計したいとします。音響ファイルには多くの異なるフォーマットがあるため（通常は拡張子で認識されます、例: `.wav`, `.aiff`, `.au`）、さまざまなファイルフォーマット間の変換のためのモジュールのコレクションを作成・維持する必要があるかもしれません。また、音響データに対して実行したいさまざまな操作（ミキシング、エコーの追加、イコライザー機能の適用、人工的なステレオ効果の作成など）もあるため、これらの操作を実行するためのモジュールを際限なく書くことになるでしょう。あなたのパッケージの考えられる構造は次のようになります（階層的なファイルシステムで表現）。

```
sound/                          トップレベルパッケージ
      __init__.py               sound パッケージを初期化
      formats/                  ファイルフォーマット変換のためのサブパッケージ
              __init__.py
              wavread.py
              wavwrite.py
              ...
      effects/                  音響効果のためのサブパッケージ
              __init__.py
              echo.py
              surround.py
              ...
      filters/                  フィルタのためのサブパッケージ
              __init__.py
              equalizer.py
              ...
```

パッケージをインポートする際、Pythonは `sys.path` 上のディレクトリを検索して、パッケージのサブディレクトリを探します。

`__init__.py` ファイルは、Pythonがそのファイルを含むディレクトリをパッケージとして扱うために必要です。これにより、`string` のような一般的な名前を持つディレクトリが、モジュール検索パスの後方にある有効なモジュールを意図せず隠してしまうのを防ぎます。最も単純なケースでは、`__init__.py` は空のファイルでかまいませんが、パッケージの初期化コードを実行したり、後述する `__all__` 変数を設定したりすることもできます。

パッケージのユーザーは、パッケージから個々のモジュールをインポートできます。例えば、

```python
import sound.effects.echo
```

これはサブモジュール `sound.effects.echo` をロードします。これは完全な名前で参照されなければなりません。

```python
sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)
```

サブモジュールをインポートする別の方法は、

```python
from sound.effects import echo
```

これもサブモジュール `echo` をロードし、パッケージプレフィックスなしで利用可能にするので、次のように使用できます。

```python
echo.echofilter(input, output, delay=0.7, atten=4)
```

さらに別のバリエーションは、目的の関数や変数を直接インポートすることです。

```python
from sound.effects.echo import echofilter
```

これもサブモジュール `echo` をロードしますが、これによりその関数 `echofilter()` が直接利用可能になります。

```python
echofilter(input, output, delay=0.7, atten=4)
```

`from package import item` を使うとき、`item` はパッケージのサブモジュール（またはサブパッケージ）か、あるいはパッケージで定義された他の名前（関数、クラス、変数など）のいずれかであることに注意してください。`import` 文はまず `item` がパッケージで定義されているかをテストし、そうでなければそれがモジュールであると仮定してロードを試みます。見つからなかった場合、`ImportError` 例外が発生します。

対照的に、`import item.subitem.subsubitem` のような構文を使う場合、最後のものを除く各 `item` はパッケージでなければなりません。最後の `item` はモジュールかパッケージのいずれかですが、前の `item` で定義されたクラスや関数、変数であってはなりません。

#### 6.4.1. パッケージから `*` をインポートする

さて、ユーザーが `from sound.effects import *` と書くと何が起こるでしょうか？理想的には、これがどうにかしてファイルシステムを調べ、パッケージ内に存在するサブモジュールを見つけて、それらすべてをインポートしてくれることを期待するでしょう。しかし、これには時間がかかる可能性があり、サブモジュールのインポートには、サブモジュールが明示的にインポートされたときにのみ起こるべき望ましくない副作用があるかもしれません。

唯一の解決策は、パッケージの作成者がパッケージの明示的なインデックスを提供することです。`import` 文は次の規約を使用します。もしパッケージの `__init__.py` コードが `__all__` という名前のリストを定義している場合、それが `from package import *` が遭遇したときにインポートされるべきモジュール名のリストであると見なされます。パッケージの新しいバージョンがリリースされたときにこのリストを最新の状態に保つのは、パッケージ作成者の責任です。パッケージ作成者は、自分のパッケージから `*` をインポートする用途がないと判断した場合、それをサポートしないと決めることもできます。例えば、`sound/effects/__init__.py` ファイルは次のコードを含むことができます。

```python
__all__ = ["echo", "surround", "reverse"]
```
これは `from sound.effects import *` が `sound.effects` パッケージの3つの名前付きサブモジュールをインポートすることを意味します。

`__all__` が定義されていない場合、`from sound.effects import *` という文は、`sound.effects` パッケージから現在の名前空間にすべてのサブモジュールをインポート**しません**。それは、パッケージ `sound.effects` がインポートされたこと（`__init__.py` の初期化コードを実行する可能性あり）を保証し、その後、パッケージで定義されている名前をインポートするだけです。これには `__init__.py` によって定義された（そして明示的にロードされたサブモジュールを含む）すべての名前が含まれます。また、以前の `import` 文によって明示的にロードされたパッケージのサブモジュールも含まれます。このコードを考えてみましょう。

```python
import sound.effects.echo
import sound.effects.surround
from sound.effects import *
```

この例では、`echo` と `surround` モジュールは、`from...import` 文が実行されたときに `sound.effects` パッケージで定義されているため、現在の名前空間にインポートされます。（これは `__all__` が定義されている場合でも機能します。）

`import *` を使うときに特定のパターンに従う名前のみをエクスポートするように設計されているモジュールもありますが、本番コードでは依然として悪い習慣と見なされています。

覚えておいてください、`from package import specific_submodule` を使うことは何も問題ありません！実際、インポートするモジュールが異なるパッケージから同名のサブモジュールを使用する必要がない限り、これが推奨される記法です。

#### 6.4.2. パッケージ内参照

パッケージが（例の `sound` パッケージのように）サブパッケージに構造化されている場合、絶対インポートを使って兄弟パッケージのサブモジュールを参照できます。例えば、`sound.filters.vocoder` モジュールが `sound.effects` パッケージの `echo` モジュールを使用する必要がある場合、`from sound.effects import echo` を使用できます。

`from module import name` 形式の `import` 文で、相対インポートを書くこともできます。これらのインポートは、先頭のドットを使って、相対インポートに関与する現在のパッケージと親パッケージを示します。例えば `surround` モジュールから、次のように使用できます。

```python
from . import echo
from .. import formats
from ..filters import equalizer
```

相対インポートは現在のモジュールの名前に基づいていることに注意してください。メインモジュールの名前は常に `"__main__"` なので、Pythonアプリケーションのメインモジュールとして使用されることを意図したモジュールは、常に絶対インポートを使用しなければなりません。

#### 6.4.3. 複数のディレクトリにまたがるパッケージ

パッケージはもう一つ特別な属性 `__path__` をサポートしています。これは、パッケージの `__init__.py` を含むディレクトリの名前を含むリストとして初期化され、そのファイル内のコードが実行される前に設定されます。この変数は変更可能であり、そうすることでパッケージに含まれるモジュールやサブパッケージの将来の検索に影響を与えます。

この機能は頻繁には必要とされませんが、パッケージ内で見つかるモジュールのセットを拡張するために使用できます。

---
**脚注**

<sup>1</sup> 実際には、関数の定義も「実行」される「文」です。モジュールレベルの関数定義が実行されると、その関数名がモジュールのグローバルシンボルテーブルに入ります。
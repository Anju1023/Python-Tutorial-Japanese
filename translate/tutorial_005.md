<!-- translate/tutorial_005.md -->

## 5. データ構造

この章では、これまでに学んだことについてさらに詳しく説明し、新しいこともいくつか追加します。

### 5.1. リストについてもう少し詳しく

リストというデータ型には、さらにいくつかのメソッドがあります。リストオブジェクトのすべてのメソッドを以下に示します。

*   `list.append(x)`
    リストの末尾に項目 `x` を追加します。`a[len(a):] = [x]` と同じ意味です。

*   `list.extend(iterable)`
    イテラブル（リストやタプルなど、反復処理が可能なオブジェクト）のすべての項目をリストの末尾に追加して、リストを拡張します。`a[len(a):] = iterable` と同じ意味です。

*   `list.insert(i, x)`
    指定された位置に項目を挿入します。最初の引数 `i` は、挿入したい位置の前にある要素のインデックスです。したがって、`a.insert(0, x)` はリストの先頭に挿入し、`a.insert(len(a), x)` は `a.append(x)` と同じ意味になります。

*   `list.remove(x)`
    リスト内で値が `x` と等しい最初の項目を削除します。そのような項目が存在しない場合は `ValueError` というエラーが発生します。

*   `list.pop([i])`
    リスト内の指定された位置にある項目を削除し、その項目を返します。インデックスが指定されていない場合、`a.pop()` はリストの最後の項目を削除して返します。（メソッドの書き方で `i` が角括弧で囲まれているのは、この引数が任意であることを示しており、実際に角括弧を入力するという意味ではありません。この記法はPythonのライブラリリファレンスでよく見られます。）

*   `list.clear()`
    リストからすべての項目を削除します。`del a[:]` と同じ意味です。

*   `list.index(x[, start[, end]])`
    リスト内で値が `x` と等しい最初の項目のインデックス（0から始まる）を返します。そのような項目が存在しない場合は `ValueError` が発生します。
    
    任意で指定できる引数 `start` と `end` はスライスの記法と同様に解釈され、リストの特定の部分シーケンス内のみを検索対象とします。返されるインデックスは、`start` 引数からではなく、リスト全体の先頭から数えた位置になります。

*   `list.count(x)`
    リスト内で `x` が出現する回数を返します。

*   `list.sort(*, key=None, reverse=False)`
    リストの項目をその場で（in-placeで）ソートします。（引数はソートのカスタマイズに使えます。詳しくは `sorted()` の説明を参照してください。）

*   `list.reverse()`
    リストの要素をその場で逆順にします。

*   `list.copy()`
    リストの「浅いコピー（shallow copy）」を返します。`a[:]` と同じ意味です。

リストのメソッドのほとんどを使った例を次に示します。

```python
>>> fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana']
>>> fruits.count('apple')
2
>>> fruits.count('tangerine')
0
>>> fruits.index('banana')
3
>>> fruits.index('banana', 4)  # 4番目の位置以降で次のbananaを探す
6
>>> fruits.reverse()
>>> fruits
['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange']
>>> fruits.append('grape')
>>> fruits
['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape']
>>> fruits.sort()
>>> fruits
['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear']
>>> fruits.pop()
'pear'
```

`insert`、`remove`、`sort` のようにリストを変更するだけのメソッドは、何も返り値を表示しないことに気づいたかもしれません。これらのメソッドはデフォルト値である `None` を返します¹。これはPythonのすべてのミュータブル（変更可能）なデータ構造における設計原則です。

もう一つ気づくかもしれないことは、すべてのデータをソートしたり比較したりできるわけではないということです。例えば、`[None, 'hello', 10]` はソートできません。なぜなら、整数は文字列と比較できず、`None` は他の型と比較できないからです。また、順序関係が定義されていない型もあります。例えば、`3+4j < 5+7j` は有効な比較ではありません。

#### 5.1.1. リストをスタックとして使う

リストのメソッドを使えば、リストをスタックとして使うのは非常に簡単です。スタックは、最後に追加された要素が最初に取り出される（「後入れ先出し」、LIFO: Last-In, First-Out）データ構造です。スタックの頂点に項目を追加するには `append()` を使います。スタックの頂点から項目を取り出すには、インデックスを指定せずに `pop()` を使います。例えば、

```python
>>> stack =
>>> stack.append(6)
>>> stack.append(7)
>>> stack

>>> stack.pop()
7
>>> stack

>>> stack.pop()
6
>>> stack.pop()
5
>>> stack

```

#### 5.1.2. リストをキューとして使う

リストをキューとして使うことも可能です。キューは、最初に追加された要素が最初に取り出される（「先入れ先出し」、FIFO: First-In, First-Out）データ構造です。しかし、リストはこの目的には効率的ではありません。リストの末尾への追加（append）や末尾からの取り出し（pop）は高速ですが、リストの先頭での挿入（insert）や取り出し（pop）は遅いのです（なぜなら、他のすべての要素を1つずつずらす必要があるからです）。

キューを実装するには、両端からの追加と取り出しが高速に行えるように設計された `collections.deque` を使うべきです。例えば、

```python
>>> from collections import deque
>>> queue = deque(["Eric", "John", "Michael"])
>>> queue.append("Terry")           # Terryが到着
>>> queue.append("Graham")          # Grahamが到着
>>> queue.popleft()                 # 最初に到着した人が去る
'Eric'
>>> queue.popleft()                 # 2番目に到着した人が去る
'John'
>>> queue                           # 到着順に残っているキュー
deque(['Michael', 'Terry', 'Graham'])
```

#### 5.1.3. リスト内包表記

リスト内包表記 (List Comprehensions) は、リストを簡潔に作成する方法を提供します。一般的な用途は、別のシーケンスやイテラブルの各メンバーに何らかの操作を適用した結果を要素とする新しいリストを作成したり、特定の条件を満たす要素のサブシーケンスを作成したりすることです。

例えば、次のような二乗のリストを作成したいとします。

```python
>>> squares = []
>>> for x in range(10):
...     squares.append(x**2)
...
>>> squares

```

このコードは `x` という名前の変数を作成（または上書き）し、その変数がループ完了後も存在し続けることに注意してください。副作用なしに二乗のリストを計算するには、次のようにします。

```python
squares = list(map(lambda x: x**2, range(10)))
```

または、それと等価で、より簡潔で読みやすいのがこちらです。

```python
squares = [x**2 for x in range(10)]
```

リスト内包表記は、角括弧 `[]` の中に、式、それに続く `for` 節、そして0個以上の `for` 節または `if` 節で構成されます。結果は、`for` 節と `if` 節のコンテキストで式を評価して得られる新しいリストになります。例えば、このリスト内包表記は、2つのリストの要素が等しくない場合にそれらを組み合わせます。

```python
>>> [(x, y) for x in for y in if x != y]
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
```
そして、これは次のコードと等価です。

```python
>>> combs = []
>>> for x in :
...     for y in :
...         if x != y:
...             combs.append((x, y))
...
>>> combs
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
```

`for` 文と `if` 文の順序が両方のスニペットで同じであることに注目してください。

式がタプル（例えば、前の例の `(x, y)`）である場合、それは丸括弧で囲む必要があります。

```python
>>> vec = [-4, -2, 0, 2, 4]
>>> # 値を2倍にした新しいリストを作成
>>> [x*2 for x in vec]
[-8, -4, 0, 4, 8]
>>> # 負の数を除外するようにリストをフィルタリング
>>> [x for x in vec if x >= 0]

>>> # すべての要素に関数を適用
>>> [abs(x) for x in vec]

>>> # 各要素でメソッドを呼び出す
>>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']
>>> [weapon.strip() for weapon in freshfruit]
['banana', 'loganberry', 'passion fruit']
>>> # (数, 二乗) のような2-タプルのリストを作成
>>> [(x, x**2) for x in range(6)]
[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]
>>> # タプルは丸括弧で囲む必要がある。さもないとエラーが発生する
>>> [x, x**2 for x in range(6)]
  File "<stdin>", line 1, in <module>
    [x, x**2 for x in range(6)]
               ^
SyntaxError: invalid syntax
>>> # 2つの 'for' を持つリスト内包表記を使ってリストをフラット化する
>>> vec = [,,]
>>> [num for elem in vec for num in elem]

```

リスト内包表記は、複雑な式やネストした関数を含むことができます。

```python
>>> from math import pi
>>> [str(round(pi, i)) for i in range(1, 6)]
['3.1', '3.14', '3.142', '3.1416', '3.14159']
```

#### 5.1.4. ネストしたリスト内包表記

リスト内包表記の最初の式は、別のリスト内包表記を含む、任意の式にすることができます。

3行4列の行列を、長さ4のリストが3つ入ったリストとして実装した次の例を考えてみましょう。

```python
>>> matrix = [
...    ,
...    ,
...    ,
... ]
```

次のリスト内包表記は、行と列を転置します。

```python
>>> [[row[i] for row in matrix] for i in range(4)]
[,,,]
```

前のセクションで見たように、ネストしたリスト内包表記は、それに続く `for` のコンテキストで評価されるので、この例は次と等価です。

```python
>>> transposed = []
>>> for i in range(4):
...     transposed.append([row[i] for row in matrix])
...
>>> transposed
[,,,]
```

そして、これはさらに次のコードと同じです。

```python
>>> transposed = []
>>> for i in range(4):
...     # 次の3行がネストしたリスト内包表記を実装している
...     transposed_row = []
...     for row in matrix:
...         transposed_row.append(row[i])
...     transposed.append(transposed_row)
...
>>> transposed
[,,,]
```

実際のプログラミングでは、複雑なフロー文よりも組み込み関数を好むべきです。このユースケースでは、`zip()` 関数が素晴らしい働きをします。

```python
>>> list(zip(*matrix))
[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]
```

この行のアスタリスク `*` の詳細については、「引数リストのアンパック」を参照してください。

### 5.2. `del` 文

リストから項目を、値ではなくインデックスで削除する方法があります。それが `del` 文です。これは値を返す `pop()` メソッドとは異なります。`del` 文は、リストからスライスを削除したり、リスト全体をクリアしたりするためにも使えます（これは以前、空のリストをスライスに代入することで行いました）。例えば、

```python
>>> a = [-1, 1, 66.25, 333, 333, 1234.5]
>>> del a
>>> a
[1, 66.25, 333, 333, 1234.5]
>>> del a[2:4]
>>> a
[1, 66.25, 1234.5]
>>> del a[:]
>>> a
[]
```

`del` は変数全体を削除するためにも使えます。

```python
>>> del a
```

この後 `a` という名前を参照すると、（少なくとも別の値が代入されるまでは）エラーになります。`del` の他の使い方は後で見ていきます。

### 5.3. タプルとシーケンス

リストと文字列には、インデックス指定やスライス操作など、多くの共通のプロパティがあることを見てきました。これらは**シーケンス**データ型の2つの例です。Pythonは進化する言語なので、他のシーケンスデータ型が追加されるかもしれません。もう一つ、標準的なシーケンスデータ型があります。それが**タプル (tuple)** です。

タプルは、カンマで区切られたいくつかの値で構成されます。例えば、

```python
>>> t = 12345, 54321, 'hello!'
>>> t
12345
>>> t
(12345, 54321, 'hello!')
>>> # タプルはネストできる
... u = t, (1, 2, 3, 4, 5)
>>> u
((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))
>>> # タプルはイミュータブル（変更不能）
... t = 88888
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>> # しかし、ミュータブル（変更可能）なオブジェクトを含むことはできる
... v = (,)
>>> v
(,)
```

ご覧のように、出力時にはタプルは常に丸括弧で囲まれているため、ネストしたタプルも正しく解釈されます。入力時には、周囲の丸括弧はあってもなくてもかまいませんが、（タプルがより大きな式の一部である場合など）多くの場合、丸括弧は必要です。タプルの個々の項目に代入することはできませんが、リストのようなミュータブルなオブジェクトを含むタプルを作成することは可能です。

タプルはリストに似ているように見えるかもしれませんが、しばしば異なる状況や異なる目的で使われます。タプルは**イミュータブル**で、通常は**アンパッキング**（このセクションの後半で説明）やインデックス指定によってアクセスされる、異種の要素のシーケンスを含みます。一方、リストは**ミュータブル**で、その要素は通常は同種であり、リストを反復処理することによってアクセスされます。

特別な問題は、0個または1個の項目を含むタプルの構築です。構文にはこれに対応するためのいくつかの癖があります。空のタプルは空の丸括弧のペアで構築されます。1つの項目を持つタプルは、値の後にカンマを続けることで構築されます（単一の値を丸括弧で囲むだけでは不十分です）。不格好ですが、効果的です。例えば、

```python
>>> empty = ()
>>> singleton = 'hello',    # <-- 末尾のカンマに注意
>>> len(empty)
0
>>> len(singleton)
1
>>> singleton
('hello',)
```

`t = 12345, 54321, 'hello!'` という文は、**タプルパッキング**の例です。値 `12345`, `54321`, `'hello!'` がタプルにまとめられています。逆の操作も可能です。

```python
>>> x, y, z = t
```

これは、**シーケンスアンパッキング**と呼ばれ、右辺のどんなシーケンスに対しても機能します。シーケンスアンパッキングでは、等号の左辺にある変数の数が、シーケンスの要素の数と等しい必要があります。多重代入は、実際にはタプルパッキングとシーケンスアンパッキングの組み合わせにすぎないことに注意してください。

### 5.4. 集合 (セット)

Pythonには、**集合 (set)** のためのデータ型も含まれています。集合は、重複する要素を持たない、順序のないコレクションです。基本的な用途には、メンバーシップテスト（ある要素が含まれているかの確認）や重複エントリの排除などがあります。集合オブジェクトは、和集合、積集合、差集合、対称差などの数学的な演算もサポートしています。

波括弧 `{}` または `set()` 関数を使って集合を作成できます。**注意:** 空の集合を作成するには `set()` を使わなければならず、`{}` ではダメです。後者は空の**辞書**を作成します。これは次のセクションで説明するデータ構造です。

簡単なデモンストレーションを次に示します。

```python
>>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
>>> print(basket)                      # 重複が削除されたことを示す
{'orange', 'banana', 'pear', 'apple'}
>>> 'orange' in basket                 # 高速なメンバーシップテスト
True
>>> 'crabgrass' in basket
False

>>> # 2つの単語から得られるユニークな文字に対する集合演算のデモ
...
>>> a = set('abracadabra')
>>> b = set('alacazam')
>>> a                                  # aに含まれるユニークな文字
{'a', 'r', 'b', 'c', 'd'}
>>> a - b                              # aには含まれるがbには含まれない文字
{'r', 'd', 'b'}
>>> a | b                              # aまたはb、あるいはその両方に含まれる文字 (和集合)
{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}
>>> a & b                              # aとbの両方に含まれる文字 (積集合)
{'a', 'c'}
>>> a ^ b                              # aまたはbに含まれるが、両方には含まれない文字 (対称差)
{'r', 'd', 'b', 'm', 'z', 'l'}
```

リスト内包表記と同様に、**集合内包表記**もサポートされています。

```python
>>> a = {x for x in 'abracadabra' if x not in 'abc'}
>>> a
{'r', 'd'}
```

### 5.5. 辞書

Pythonに組み込まれているもう一つの便利なデータ型は**辞書 (dictionary)** です。辞書は他の言語では「連想メモリ」や「連想配列」として見られます。数値の範囲によってインデックス付けされるシーケンスとは異なり、辞書は**キー**によってインデックス付けされます。キーは任意のイミュータブルな型にすることができます。文字列と数値は常にキーにできます。タプルは、文字列、数値、またはタプルのみを含む場合にキーとして使用できます。タプルが直接または間接的にミュータブルなオブジェクトを含む場合、キーとして使用することはできません。リストをキーとして使用することはできません。なぜなら、リストはインデックス代入、スライス代入、または `append()` や `extend()` のようなメソッドを使ってその場で変更できるからです。

辞書は `キー: 値` のペアの集合と考えるのが最善です。ただし、キーは（1つの辞書内で）ユニークでなければならないという要件があります。波括弧のペア `{}` は空の辞書を作成します。波括弧内にカンマ区切りの `キー:値` のペアのリストを置くと、辞書に初期の `キー:値` のペアが追加されます。これは、辞書が出力時に書かれる方法でもあります。

辞書の主な操作は、あるキーで値を保存することと、キーを与えて値を抽出することです。`del` を使って `キー:値` のペアを削除することも可能です。すでに使用中のキーを使って保存すると、そのキーに関連付けられていた古い値は忘れ去られます。存在しないキーを使って値を抽出しようとするとエラーになります。

辞書に対して `list(d)` を実行すると、その辞書で使用されているすべてのキーのリストが挿入順で返されます（ソートしたい場合は、代わりに `sorted(d)` を使ってください）。単一のキーが辞書にあるかどうかをチェックするには、`in` キーワードを使います。

辞書を使った小さな例を次に示します。

```python
>>> tel = {'jack': 4098, 'sape': 4139}
>>> tel['guido'] = 4127
>>> tel
{'jack': 4098, 'sape': 4139, 'guido': 4127}
>>> tel['jack']
4098
>>> del tel['sape']
>>> tel['irv'] = 4127
>>> tel
{'jack': 4098, 'guido': 4127, 'irv': 4127}
>>> list(tel)
['jack', 'guido', 'irv']
>>> sorted(tel)
['guido', 'irv', 'jack']
>>> 'guido' in tel
True
>>> 'jack' not in tel
False
```

`dict()` コンストラクタは、キーと値のペアのシーケンスから直接辞書を構築します。

```python
>>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
{'sape': 4139, 'guido': 4127, 'jack': 4098}
```
さらに、**辞書内包表記**を使って、任意のキーと値の式から辞書を作成することができます。

```python
>>> {x: x**2 for x in (2, 4, 6)}
{2: 4, 4: 16, 6: 36}
```
キーが単純な文字列の場合、キーワード引数を使ってペアを指定する方が簡単な場合があります。

```python
>>> dict(sape=4139, guido=4127, jack=4098)
{'sape': 4139, 'guido': 4127, 'jack': 4098}
```

### 5.6. ループのテクニック

辞書をループ処理するとき、`items()` メソッドを使うと、キーと対応する値を同時に取得できます。

```python
>>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}
>>> for k, v in knights.items():
...     print(k, v)
...
gallahad the pure
robin the brave
```

シーケンスをループ処理するとき、`enumerate()` 関数を使うと、位置インデックスと対応する値を同時に取得できます。

```python
>>> for i, v in enumerate(['tic', 'tac', 'toe']):
...     print(i, v)
...
0 tic
1 tac
2 toe
```

2つ以上のシーケンスを同時にループ処理するには、`zip()` 関数でエントリをペアにすることができます。

```python
>>> questions = ['name', 'quest', 'favorite color']
>>> answers = ['lancelot', 'the holy grail', 'blue']
>>> for q, a in zip(questions, answers):
...     print('What is your {0}?  It is {1}.'.format(q, a))
...
What is your name?  It is lancelot.
What is your quest?  It is the holy grail.
What is your favorite color?  It is blue.
```

シーケンスを逆順にループ処理するには、まずシーケンスを順方向に指定し、次に `reversed()` 関数を呼び出します。

```python
>>> for i in reversed(range(1, 10, 2)):
...     print(i)
...
9
7
5
3
1
```

シーケンスをソートされた順序でループ処理するには、`sorted()` 関数を使います。これは元のソースを変更せずに、新しいソート済みのリストを返します。

```python
>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
>>> for i in sorted(basket):
...     print(i)
...
apple
apple
banana
orange
orange
pear
```

シーケンスに対して `set()` を使うと、重複した要素が排除されます。シーケンスに対して `sorted()` と `set()` を組み合わせて使うのは、シーケンスのユニークな要素をソートされた順序でループ処理するための慣用的な方法です。

```python
>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
>>> for f in sorted(set(basket)):
...     print(f)
...
apple
banana
orange
pear```

ループ処理中にリストを変更したくなることがありますが、多くの場合、代わりに新しいリストを作成する方がより簡単で安全です。

```python
>>> import math
>>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]
>>> filtered_data = []
>>> for value in raw_data:
...     if not math.isnan(value):
...         filtered_data.append(value)
...
>>> filtered_data
[56.2, 51.7, 55.3, 52.5, 47.8]
```

### 5.7. 条件についてもう少し

`while` 文や `if` 文で使われる条件には、比較だけでなく、任意の演算子を含めることができます。

比較演算子 `in` と `not in` は、ある値がシーケンス内に存在するか（しないか）をチェックします。演算子 `is` と `is not` は、2つのオブジェクトが本当に同じオブジェクトであるかどうかを比較します。すべての比較演算子は同じ優先順位を持ち、これはすべての数値演算子の優先順位よりも低いです。

比較は連鎖させることができます。例えば、`a < b == c` は、`a` が `b` より小さく、かつ `b` が `c` と等しいかどうかをテストします。

比較はブール演算子 `and` と `or` を使って組み合わせることができ、比較の結果（または他のブール式の結果）は `not` で否定することができます。これらは比較演算子よりも低い優先順位を持ちます。その中では `not` が最も優先順位が高く、`or` が最も低いので、`A and not B or C` は `(A and (not B)) or C` と等価です。いつものように、丸括弧を使って望む組み合わせを表現することができます。

ブール演算子 `and` と `or` は、いわゆる**短絡評価 (short-circuit)** 演算子です。その引数は左から右へと評価され、結果が確定した時点で評価が停止します。例えば、`A` と `C` が真で `B` が偽の場合、`A and B and C` は式 `C` を評価しません。ブール値としてではなく一般の値として使われる場合、短絡評価演算子の返り値は最後に評価された引数になります。

比較や他のブール式の結果を変数に代入することが可能です。例えば、

```python
>>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'
>>> non_null = string1 or string2 or string3
>>> non_null
'Trondheim'
```

Pythonでは、C言語とは異なり、式の中での代入はセイウチ演算子 `:=` を使って明示的に行う必要があることに注意してください。これにより、Cプログラムでよく見られる、`==` のつもりが `=` とタイプしてしまうという一般的な問題のクラスを回避できます。

### 5.8. シーケンスやその他の型の比較

シーケンスオブジェクトは通常、同じシーケンス型の他のオブジェクトと比較することができます。比較は**辞書式順序**を使用します。まず最初の2つの項目が比較され、もしそれらが異なれば、それが比較の結果を決定します。もしそれらが等しければ、次の2つの項目が比較され、というように、どちらかのシーケンスが尽きるまで続きます。比較される2つの項目自体が同じ型のシーケンスである場合、辞書式比較が再帰的に実行されます。2つのシーケンスのすべての項目が等しいと比較された場合、シーケンスは等しいと見なされます。一方のシーケンスが他方の初期サブシーケンスである場合、短い方のシーケンスが小さい（lesser）方になります。文字列の辞書式順序は、個々の文字を順序付けるためにUnicodeのコードポイント番号を使用します。同じ型のシーケンス間の比較の例をいくつか示します。

```
(1, 2, 3)              < (1, 2, 4)
              <
'ABC' < 'C' < 'Pascal' < 'Python'
(1, 2, 3, 4)           < (1, 2, 4)
(1, 2)                 < (1, 2, -1)
             == (1.0, 2.0, 3.0)
(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)
```

異なる型のオブジェクトを `<` や `>` で比較することは、オブジェクトが適切な比較メソッドを持っている限り合法であることに注意してください。例えば、混合された数値型は、その数値的な値に従って比較されるので、`0` は `0.0` と等しくなります。それ以外の場合、インタプリタは任意の順序を提供するのではなく、`TypeError` 例外を発生させます。

---
**脚注**

<sup>1</sup> 他の言語では、変更されたオブジェクトを返すことがあり、これにより `d->insert("a")->remove("b")->sort();` のようなメソッドチェーンが可能になります。
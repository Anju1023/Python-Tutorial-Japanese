<!-- claude_translate/tutorial_007.md -->

# 7. 入出力

プログラムの出力を表示する方法はいくつかある:
- 人間が読める形式でデータを表示
- 将来使うためにファイルに書き込む

この章では、いくつかの可能性を議論するよ。

## 7.1. より洗練された出力フォーマット

**これまでに出会った値を書く2つの方法:**
1. 式文
2. `print()` 関数

**3つ目の方法:**
- ファイルオブジェクトの `write()` メソッド
- 標準出力ファイルは `sys.stdout` として参照できる
- 詳しくはLibrary Referenceを見てね

**もっと制御したい:**
- 単にスペース区切りの値を表示するより、出力のフォーマットをもっと制御したいことが多い

### 出力をフォーマットする方法

**方法1: フォーマット済み文字列リテラル(f-strings)**
- 文字列の前に `f` または `F` を付ける
- 開始引用符または三重引用符の前
- この文字列内で、`{` と `}` の間にPython式を書ける
- 変数やリテラル値を参照できる

```python
>>> year = 2016
>>> event = 'Referendum'
>>> f'Results of the {year} {event}'
'Results of the 2016 Referendum'
```

**方法2: 文字列の `str.format()` メソッド**
- もっと手動の努力が必要
- `{` と `}` で変数が置換される場所をマーク
- 詳細なフォーマット指示を提供できる
- フォーマットする情報も提供する必要がある

```python
>>> yes_votes = 42_572_654
>>> no_votes = 43_132_495
>>> percentage = yes_votes / (yes_votes + no_votes)
>>> '{:-9} YES votes  {:2.2%}'.format(yes_votes, percentage)
' 42572654 YES votes  49.67%'
```

**方法3: 自分で文字列処理**
- 文字列スライスと連結操作で、想像できる任意のレイアウトを作成
- 文字列型には、文字列を特定の列幅にパディングする便利なメソッドがある

### str()とrepr()

**デバッグ用に変数をサクッと表示したい場合:**
- `repr()` または `str()` 関数で任意の値を文字列に変換

**`str()` 関数:**
- 人間が読みやすい値の表現を返すことを意図

**`repr()` 関数:**
- インタープリタが読める表現を生成することを意図
- (または同等の構文がない場合は `SyntaxError` を強制)
- 人間用の特定の表現がないオブジェクトの場合、`str()` は `repr()` と同じ値を返す
- 数値やリスト、辞書のような構造など、多くの値はどちらの関数でも同じ表現
- 文字列は特に、2つの異なる表現を持つ

**例:**

```python
>>> s = 'Hello, world.'
>>> str(s)
'Hello, world.'
>>> repr(s)
"'Hello, world.'"
>>> str(1/7)
'0.14285714285714285'
>>> x = 10 * 3.25
>>> y = 200 * 200
>>> s = 'The value of x is ' + repr(x) + ', and y is ' + repr(y) + '...'
>>> print(s)
The value of x is 32.5, and y is 40000...

>>> # repr()は文字列に引用符とバックスラッシュを追加:
... hello = 'hello, world\n'
>>> hellos = repr(hello)
>>> print(hellos)
'hello, world\n'

>>> # repr()の引数は任意のPythonオブジェクト:
... repr((x, y, ('spam', 'eggs')))
"(32.5, 40000, ('spam', 'eggs'))"
```

**`string` モジュール:**
- `Template` クラスを含む
- `$x` のようなプレースホルダーを使って値を文字列に置換する別の方法を提供
- 辞書から値で置換
- でもフォーマットの制御ははるかに少ない

## 7.1.1. フォーマット済み文字列リテラル

**フォーマット済み文字列リテラル(f-stringsとも呼ばれる):**
- 文字列の前に `f` または `F` を付けて
- `{expression}` として式を書くことで
- 文字列内にPython式の値を含められる

**オプションのフォーマット指定子:**
- 式の後に続けられる
- 値のフォーマット方法をより細かく制御できる

**例: piを小数点以下3桁に丸める**

```python
>>> import math
>>> print(f'The value of pi is approximately {math.pi:.3f}.')
The value of pi is approximately 3.142.
```

**`:` の後に整数を渡す:**
- そのフィールドが最小の文字数幅になる
- 列を揃えるのに便利

```python
>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
>>> for name, phone in table.items():
...     print(f'{name:10} ==> {phone:10d}')
...
Sjoerd     ==>       4127
Jack       ==>       4098
Dcab       ==>       7678
```

### 変換修飾子

**他の修飾子でフォーマット前に値を変換:**
- `!a`: `ascii()` を適用
- `!s`: `str()` を適用
- `!r`: `repr()` を適用

```python
>>> animals = 'eels'
>>> print(f'My hovercraft is full of {animals}.')
My hovercraft is full of eels.
>>> print(f'My hovercraft is full of {animals!r}.')
My hovercraft is full of 'eels'.
```

これらのフォーマット仕様のリファレンスは、「Format Specification Mini-Language」のリファレンスガイドを見てね。

## 7.1.2. 文字列のformat()メソッド

**`str.format()` メソッドの基本的な使い方:**

```python
>>> print('We are the {} who say "{}!"'.format('knights', 'Ni'))
We are the knights who say "Ni!"
```

**括弧と中の文字(フォーマットフィールドと呼ばれる):**
- `str.format()` メソッドに渡されたオブジェクトで置換される

**括弧内の数値:**
- `str.format()` メソッドに渡されたオブジェクトの位置を参照できる

```python
>>> print('{0} and {1}'.format('spam', 'eggs'))
spam and eggs
>>> print('{1} and {0}'.format('spam', 'eggs'))
eggs and spam
```

### キーワード引数

**`str.format()` メソッドでキーワード引数を使う場合:**
- 引数の名前を使って値を参照

```python
>>> print('This {food} is {adjective}.'.format(
...       food='spam', adjective='absolutely horrible'))
This spam is absolutely horrible.
```

**位置引数とキーワード引数を任意に組み合わせ:**

```python
>>> print('The story of {0}, {1}, and {other}.'.format('Bill', 'Manfred',
...                                                      other='Georg'))
The story of Bill, Manfred, and Georg.
```

### 辞書を使ったフォーマット

**本当に長いフォーマット文字列を分割したくない場合:**
- 位置じゃなく名前でフォーマットする変数を参照できたらいいよね
- 辞書を渡して角括弧 `[]` でキーにアクセスすればできる

```python
>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
>>> print('Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; '
...       'Dcab: {0[Dcab]:d}'.format(table))
Jack: 4098; Sjoerd: 4127; Dcab: 8637678
```

**`**` 記法でキーワード引数として渡すこともできる:**

```python
>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
>>> print('Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; Dcab: {Dcab:d}'.format(**table))
Jack: 4098; Sjoerd: 4127; Dcab: 8637678
```

**これは組み込み関数 `vars()` と組み合わせると特に便利:**
- すべてのローカル変数を含む辞書を返す

### フォーマット例

**整数とその2乗、3乗のきれいに揃った列:**

```python
>>> for x in range(1, 11):
...     print('{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x))
...
 1   1    1
 2   4    8
 3   9   27
 4  16   64
 5  25  125
 6  36  216
 7  49  343
 8  64  512
 9  81  729
10 100 1000
```

`str.format()` での文字列フォーマットの完全な概要は、「Format String Syntax」を見てね。

## 7.1.3. 手動での文字列フォーマット

**同じ2乗と3乗のテーブル、手動でフォーマット:**

```python
>>> for x in range(1, 11):
...     print(repr(x).rjust(2), repr(x*x).rjust(3), end=' ')
...     # 前の行の'end'の使用に注目
...     print(repr(x*x*x).rjust(4))
...
 1   1    1
 2   4    8
 3   9   27
 4  16   64
 5  25  125
 6  36  216
 7  49  343
 8  64  512
 9  81  729
10 100 1000
```

**(各列間の1スペースは `print()` の動作で追加された: 引数間に常にスペースを追加する)**

### 文字列のパディングメソッド

**`str.rjust()` メソッド:**
- 指定された幅のフィールド内で文字列を右寄せ
- 左側にスペースでパディング

**類似メソッド:**
- `str.ljust()`: 左寄せ
- `str.center()`: 中央寄せ

**これらのメソッドの特徴:**
- 何も書き込まない、新しい文字列を返すだけ
- 入力文字列が長すぎる場合、切り詰めない、変更せずに返す
  - 列レイアウトが崩れるけど、値について嘘をつくよりマシ
- (本当に切り詰めたい場合、スライス操作を追加できる: `x.ljust(n)[:n]`)

**`str.zfill()` メソッド:**
- 数値文字列の左側をゼロでパディング
- プラスとマイナス記号を理解する

```python
>>> '12'.zfill(5)
'00012'
>>> '-3.14'.zfill(7)
'-003.14'
>>> '3.14159265359'.zfill(5)
'3.14159265359'
```

## 7.1.4. 古い文字列フォーマット

**`%` 演算子(剰余)も文字列フォーマットに使える:**

**`'string' % values` が与えられると:**
- `string` 内の `%` のインスタンスが、`values` の0個以上の要素で置換される
- この操作は一般に**文字列補間**として知られてる

```python
>>> import math
>>> print('The value of pi is approximately %5.3f.' % math.pi)
The value of pi is approximately 3.142.
```

詳しくは「printf-style String Formatting」セクションを見てね。

## 7.2. ファイルの読み書き

**`open()` はファイルオブジェクトを返す:**
- 最も一般的には、2つの位置引数と1つのキーワード引数で使われる

```python
open(filename, mode, encoding=None)
```

**例:**

```python
>>> f = open('workfile', 'w', encoding="utf-8")
```

### 引数の説明

**第1引数:**
- ファイル名を含む文字列

**第2引数:**
- ファイルの使用方法を記述する数文字を含む別の文字列

**`mode` の値:**
- `'r'`: ファイルは読み取り専用
- `'w'`: 書き込み専用(同名の既存ファイルは消去される)
- `'a'`: 追加用にファイルを開く(書き込まれたデータは自動的に最後に追加)
- `'r+'`: 読み書き両方用にファイルを開く
- mode引数はオプション、省略すると `'r'` と見なされる

### テキストモードとバイナリモード

**通常、ファイルはテキストモードで開かれる:**
- 文字列をファイルから読んだり書いたりする
- 特定のエンコーディングでエンコード

**エンコーディングが指定されてない場合:**
- デフォルトはプラットフォーム依存(`open()` を見てね)
- UTF-8は現代の事実上の標準だから
- 別のエンコーディングを使う必要があると分かってない限り、`encoding="utf-8"` が推奨

**modeに `'b'` を追加:**
- ファイルをバイナリモードで開く
- バイナリモードのデータは `bytes` オブジェクトとして読み書きされる
- バイナリモードでファイルを開く時、エンコーディングは指定できない

**テキストモード:**
- 読み取り時のデフォルトは、プラットフォーム固有の行末(Unixでは `\n`、Windowsでは `\r\n`)を単なる `\n` に変換
- テキストモードで書き込む時のデフォルトは、`\n` の出現をプラットフォーム固有の行末に変換
- この舞台裏でのファイルデータ変更はテキストファイルには問題ないけど
- JPEGやEXEファイルのようなバイナリデータは破損する
- **そのようなファイルを読み書きする時は、バイナリモードを使うよう細心の注意を!**

### withステートメントの使用

**ファイルオブジェクトを扱う時は `with` キーワードを使うのが良い習慣:**

**利点:**
- スイートが終了した後、ファイルが適切に閉じられる
- 途中で例外が発生しても閉じられる
- `with` を使う方が、同等の `try-finally` ブロックを書くよりずっと短い

```python
>>> with open('workfile', encoding="utf-8") as f:
...     read_data = f.read()

>>> # ファイルが自動的に閉じられたことを確認できる
>>> f.closed
True
```

### withを使わない場合

**`with` キーワードを使ってない場合:**
- `f.close()` を呼び出してファイルを閉じる
- ファイルが使うシステムリソースを即座に解放する

**警告:**
- `with` キーワードを使わずに `f.write()` を呼び出す、または `f.close()` を呼び出すと
- プログラムが正常に終了しても、`f.write()` の引数がディスクに完全に書き込まれない可能性がある

**ファイルオブジェクトが閉じられた後:**
- `with` 文または `f.close()` の呼び出しで閉じられた後
- ファイルオブジェクトを使おうとすると、自動的に失敗する

```python
>>> f.close()
>>> f.read()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: I/O operation on closed file.
```

## 7.2.1. ファイルオブジェクトのメソッド

このセクションの残りの例では、ファイルオブジェクト `f` が既に作成されてると仮定するよ。

### f.read(size)

**ファイルの内容を読む:**
- ある量のデータを読んで、文字列(テキストモード)または bytes オブジェクト(バイナリモード)として返す
- `size` はオプションの数値引数
- `size` が省略または負の場合、ファイルの全内容を読んで返す
  - ファイルがマシンのメモリの2倍の大きさだったら、あなたの問題!
- それ以外の場合、最大で `size` 文字(テキストモード)または `size` バイト(バイナリモード)を読んで返す
- ファイルの最後に達した場合、`f.read()` は空文字列(`''`)を返す

```python
>>> f.read()
'This is the entire file.\n'
>>> f.read()
''
```

### f.readline()

**ファイルから1行読む:**
- 改行文字(`\n`)は文字列の最後に残る
- ファイルが改行で終わってない場合のみ、ファイルの最後の行で省略される
- これにより戻り値が明確になる
- `f.readline()` が空文字列を返す → ファイルの最後に達した
- 空行は `'\n'` で表される(改行だけを含む文字列)

```python
>>> f.readline()
'This is the first line of the file.\n'
>>> f.readline()
'Second line of the file\n'
>>> f.readline()
''
```

### ファイルから行を読むループ

**ファイルから行を読むには、ファイルオブジェクトをループできる:**
- メモリ効率的、高速、シンプルなコード

```python
>>> for line in f:
...     print(line, end='')
...
This is the first line of the file.
Second line of the file
```

**ファイルのすべての行をリストで読みたい場合:**
- `list(f)` または `f.readlines()` も使える

### f.write(string)

**文字列の内容をファイルに書く:**
- 書き込まれた文字数を返す

```python
>>> f.write('This is a test\n')
15
```

**他の型のオブジェクト:**
- 書き込む前に変換が必要
- 文字列(テキストモード)または bytes オブジェクト(バイナリモード)に

```python
>>> value = ('the answer', 42)
>>> s = str(value)  # タプルを文字列に変換
>>> f.write(s)
18
```

### f.tell()

**ファイルオブジェクトの現在位置を返す整数:**
- バイナリモード: ファイルの先頭からのバイト数
- テキストモード: 不透明な数値

### f.seek(offset, whence)

**ファイルオブジェクトの位置を変更:**
- 位置は、参照ポイントに `offset` を加えて計算
- 参照ポイントは `whence` 引数で選択

**`whence` の値:**
- `0`: ファイルの先頭から測定
- `1`: 現在のファイル位置を使用
- `2`: ファイルの最後を参照ポイントとして使用
- `whence` は省略可能、デフォルトは `0`(ファイルの先頭を参照ポイント)

```python
>>> f = open('workfile', 'rb+')
>>> f.write(b'0123456789abcdef')
16
>>> f.seek(5)      # ファイルの6番目のバイトに移動
5
>>> f.read(1)
b'5'
>>> f.seek(-3, 2)  # 最後から3番目のバイトに移動
13
>>> f.read(1)
b'd'
```

**テキストファイル(modeに `b` がない)の場合:**
- ファイルの先頭からの相対的なseekのみ許可
  - (例外は `seek(0, 2)` でファイルの最後までseek)
- 有効なoffset値は `f.tell()` から返されたもの、またはゼロのみ
- 他のoffset値は未定義の動作を生成

**他のメソッド:**
- ファイルオブジェクトには `isatty()` や `truncate()` のようなあまり使われないメソッドもある
- ファイルオブジェクトの完全ガイドはLibrary Referenceを参照

## 7.2.2. jsonで構造化データを保存

**文字列はファイルに簡単に書き込み・読み取りできる:**
- 数値はもう少し努力が必要
- `read()` メソッドは文字列しか返さない
- `'123'` のような文字列を取って数値 `123` を返す `int()` のような関数に渡す必要がある

**もっと複雑なデータ型を保存したい場合:**
- ネストしたリストや辞書のような
- 手でパースとシリアライズするのが複雑になる

**解決策: JSON(JavaScript Object Notation)**
- ユーザーが複雑なデータ型をファイルに保存するためのコードを常に書いてデバッグするより
- Pythonは人気のあるデータ交換フォーマットのJSONを使える
- `json` と呼ばれる標準モジュールが、Pythonデータ階層を取って、文字列表現に変換できる
  - このプロセスを**シリアライズ**という
- 文字列表現からデータを再構築することを**デシリアライズ**という
- シリアライズとデシリアライズの間、オブジェクトを表す文字列は:
  - ファイルやデータに保存されたかも
  - ネットワーク接続で遠くのマシンに送られたかも

**注意:**
JSONフォーマットは、データ交換を可能にするために現代のアプリケーションで一般的に使われてる。多くのプログラマーが既に慣れてるから、相互運用性のための良い選択。

### JSONの使い方

**オブジェクト `x` がある場合、そのJSON文字列表現を見る:**

```python
>>> import json
>>> x = [1, 'simple', 'list']
>>> json.dumps(x)
'[1, "simple", "list"]'
```

**`dumps()` 関数の別のバリアント `dump()`:**
- 単にオブジェクトをテキストファイルにシリアライズ
- `f` が書き込み用に開かれたテキストファイルオブジェクトなら:

```python
json.dump(x, f)
```

**オブジェクトを再度デコード:**
- `f` が読み取り用に開かれたバイナリまたはテキストファイルオブジェクトなら:

```python
x = json.load(f)
```

**注意:**
JSONファイルはUTF-8でエンコードする必要がある。読み書き両方でJSONファイルをテキストファイルとして開く時、`encoding="utf-8"` を使ってね。

### JSONの制限

**このシンプルなシリアライズ技術:**
- リストと辞書を扱える
- でも、任意のクラスインスタンスをJSONでシリアライズするには、もう少し追加の努力が必要
- `json` モジュールのリファレンスにこの説明がある

### pickle モジュール

**JSONとは対照的に:**
- `pickle` は任意に複雑なPythonオブジェクトのシリアライズを許可するプロトコル
- そのため、Pythonに固有で、他の言語で書かれたアプリケーションとの通信には使えない
- デフォルトで安全じゃない:
  - 信頼できないソースからのpickleデータをデシリアライズすると、任意のコードを実行できる
  - データが熟練した攻撃者によって作られた場合

---

## この章の重要ポイントまとめ( ˶'ᵕ'˶)

### 出力フォーマット
- **f-strings**: `f'text {variable}'` (最もモダンで簡単!)
- **str.format()**: `'text {}'.format(value)`
- **%演算子**: `'text %s' % value` (古い方法)

### 文字列メソッド
- `str.rjust()`, `str.ljust()`, `str.center()`: パディング
- `str.zfill()`: ゼロでパディング
- `str()`, `repr()`: 文字列変換

### ファイル操作
- **`open(filename, mode, encoding="utf-8")`**
- **mode**: `'r'`(読取), `'w'`(書込), `'a'`(追加), `'r+'`(読書), `'b'`(バイナリ)
- **`with`文を使おう!**(自動でファイルを閉じる)

### ファイルメソッド
- `f.read(size)`: 読み取り
- `f.readline()`: 1行読み取り
- `f.write(string)`: 書き込み
- `f.tell()`: 現在位置
- `f.seek(offset, whence)`: 位置変更

### JSON
- `json.dumps(obj)`: オブジェクト→JSON文字列
- `json.dump(obj, file)`: オブジェクト→ファイル
- `json.load(file)`: ファイル→オブジェクト
- UTF-8エンコーディングを使おう!

次は8章いくよ〜!URL貼って!( ˶>ᴗ<˶)
<!-- claude_translate/tutorial_003.md -->

# 3. Pythonの非公式入門

## この章の読み方

このチュートリアルの例では、入力と出力をプロンプトで区別してるよ:

- **`>>>`** (プライマリプロンプト) や **`...`** (セカンダリプロンプト) = 入力
- **プロンプトなし** = 出力(インタープリタからの応答)

**例を試す時:**
- プロンプトの**後ろ**の部分だけを入力してね
- プロンプト自体は打たないこと!

**空行の入力:**
- セカンダリプロンプト `...` だけの行 = 空行を入力するってこと
- 複数行コマンドの終わりを示すために使うよ

**便利機能:**
- 例のボックスの右上にある `>>>` をクリックすると、プロンプトと出力の表示/非表示を切り替えられる
- 隠せば、入力行だけを簡単にコピペできる!

## コメントについて

このマニュアルの例には、対話的プロンプトで入力したものでも、コメントが含まれてることがあるよ。

**Pythonのコメント:**
- **ハッシュ文字 `#` で始まる**
- その行の終わりまで続く
- 行の最初に書いてもいいし、空白やコードの後に書いてもOK
- **文字列リテラルの中は例外**: 文字列の中の `#` はただのハッシュ文字

**コメントの役割:**
- コードをわかりやすくする
- Pythonは解釈しない(実行に影響なし)
- 例を試す時は省略してもいい

**例:**
```python
# これが最初のコメント
spam = 1  # これが2番目のコメント
          # ... そして3番目!
text = "# これはコメントじゃない。引用符の中だから。"
```

## 3.1. 電卓としてPythonを使う

簡単なPythonコマンドを試してみよう!インタープリタを起動して、プライマリプロンプト `>>>` が出るのを待って。

### 3.1.1. 数値

インタープリタは簡単な電卓として動くよ。式を入力すると、値を計算して表示してくれる。

**式の構文は超シンプル:**
- 演算子 `+`, `-`, `*`, `/` は他の言語(PascalやCとか)と同じ
- 括弧 `()` でグループ化できる

**例:**
```python
>>> 2 + 2
4
>>> 50 - 5*6
20
>>> (50 - 5*6) / 4
5.0
>>> 8 / 5  # 割り算は常に浮動小数点数を返す
1.6
```

**数値の型:**
- **整数**(例: `2`, `4`, `20`) = `int` 型
- **小数部分がある数**(例: `5.0`, `1.6`) = `float` 型
- 数値型については後で詳しくやるよ!

#### 割り算のルール

**通常の割り算 `/`:**
- **常に `float` を返す**

**切り捨て除算 `//`:**
- 小数部分を切り捨てて整数の結果を返す

**剰余(余り) `%`:**
- 割り算の余りを計算

**例:**
```python
>>> 17 / 3  # 通常の割り算 → floatを返す
5.666666666666667

>>> 17 // 3  # 切り捨て除算 → 小数部分を捨てる
5

>>> 17 % 3  # % 演算子は余りを返す
2

>>> 5 * 3 + 2  # 商 × 除数 + 余り
17
```

#### べき乗

Pythonでは `**` 演算子でべき乗が計算できるよ!

```python
>>> 5 ** 2  # 5の2乗
25
>>> 2 ** 7  # 2の7乗
128
```

**注意!**
`**` は `-` より優先度が高いから:
- `-3**2` は `-(3**2)` と解釈されて `-9` になる
- `9` が欲しい時は `(-3)**2` って書こう

#### 変数への代入

**等号 `=` で値を変数に代入できる:**

```python
>>> width = 20
>>> height = 5 * 9
>>> width * height
900
```

代入後は、次の対話的プロンプトまで結果は表示されないよ。

**未定義の変数を使おうとするとエラー:**

```python
>>> n  # 未定義の変数にアクセスしようとする
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'n' is not defined
```

#### 浮動小数点のサポート

浮動小数点は完全サポート!

**異なる型の演算子が混在する場合:**
- 整数オペランドが自動的に浮動小数点に変換される

```python
>>> 4 * 3.75 - 1
14.0
```

#### 便利な `_` 変数

**対話モードでの特別機能:**
- 最後に表示された式の結果が、自動的に変数 `_` に代入される
- 電卓として使う時、計算の続きがめっちゃ楽!

**例:**
```python
>>> tax = 12.5 / 100
>>> price = 100.50
>>> price * tax
12.5625
>>> price + _  # _ には直前の結果 12.5625 が入ってる
113.0625
>>> round(_, 2)
113.06
```

**注意:**
- `_` は**読み取り専用**として扱おう
- 明示的に値を代入しないこと!
  - 代入すると、同じ名前のローカル変数ができて、マジック動作する組み込み変数がマスクされちゃう

#### その他の数値型

`int` と `float` 以外にも、Pythonは色々な数値型をサポートしてる:

- **`Decimal`**(10進数)
- **`Fraction`**(分数)
- **複素数**: `j` または `J` 接尾辞で虚数部を表す(例: `3+5j`)

### 3.1.2. 文字列

数値以外に、Pythonは文字列も操作できるよ!文字列の表現方法はいくつかある。

#### クォートの使い方

**シングルクォート `'...'` かダブルクォート `"..."` で囲む:**
- 結果は同じ!
- `\` でクォートをエスケープできる

```python
>>> 'spam eggs'  # シングルクォート
'spam eggs'

>>> 'doesn\'t'  # \' でシングルクォートをエスケープ
"doesn't"

>>> "doesn't"  # またはダブルクォートを使う
"doesn't"

>>> '"Yes," they said.'
'"Yes," they said.'

>>> "\"Yes,\" they said."
'"Yes," they said.'

>>> '"Isn\'t," they said.'
'"Isn\'t," they said.'
```

#### 対話的インタープリタでの出力

インタープリタでは:
- 出力文字列はクォートで囲まれる
- 特殊文字はバックスラッシュでエスケープされる
- 入力と見た目が違うことがあるけど、2つの文字列は等価
- 文字列にシングルクォートが含まれてダブルクォートがない場合 → ダブルクォートで囲む
- それ以外 → シングルクォートで囲む

**`print()` 関数の方が読みやすい:**
- クォートを省略
- エスケープ文字や特殊文字を実際に表示

```python
>>> '"Isn\'t," they said.'
'"Isn\'t," they said.'

>>> print('"Isn\'t," they said.')
"Isn't," they said.

>>> s = 'First line.\nSecond line.'  # \n = 改行
>>> s  # print()なし → \n が含まれて表示される
'First line.\nSecond line.'

>>> print(s)  # print()あり → \n で改行が生成される
First line.
Second line.
```

#### Raw文字列

`\` で始まる文字を特殊文字として解釈したくない時は、**raw文字列**を使おう!

最初のクォートの前に `r` を付けるだけ:

```python
>>> print('C:\some\name')  # \n が改行になっちゃう!
C:\some
ame

>>> print(r'C:\some\name')  # クォートの前の r に注目
C:\some\name
```

#### 複数行の文字列リテラル

**トリプルクォート `"""..."""` または `'''...'''` を使う:**
- 行末は自動的に文字列に含まれる
- 行末に `\` を付けると含まれなくなる

**例:**
```python
print("""\
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
""")
```

**出力:**(最初の改行は含まれないよ)
```
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
```

#### 文字列の連結と繰り返し

**`+` で連結(くっつける):**
**`*` で繰り返し:**

```python
>>> 3 * 'un' + 'ium'  # 3回 'un' を繰り返して 'ium' を追加
'unununium'
```

**リテラル同士の自動連結:**
- 2つ以上の文字列リテラルを隣に置くと、自動的に連結される

```python
>>> 'Py' 'thon'
'Python'
```

**長い文字列を分割するのに便利:**

```python
>>> text = ('Put several strings within parentheses '
...         'to have them joined together.')
>>> text
'Put several strings within parentheses to have them joined together.'
```

**注意:**
- これは**リテラル同士でのみ**動く
- 変数や式には使えない!

```python
>>> prefix = 'Py'
>>> prefix 'thon'  # 変数とリテラルは連結できない
  File "<stdin>", line 1
    prefix 'thon'
           ^^^^^^
SyntaxError: invalid syntax

>>> ('un' * 3) 'ium'  # 式とリテラルも無理
  File "<stdin>", line 1
    ('un' * 3) 'ium'
               ^^^^^
SyntaxError: invalid syntax
```

**変数やリテラルを連結したい時は `+` を使う:**

```python
>>> prefix + 'thon'
'Python'
```

#### 文字列のインデックス(添字)

文字列はインデックスでアクセスできるよ。最初の文字のインデックスは `0`。

**Pythonには独立した文字型はない:**
- 文字 = サイズ1の文字列

```python
>>> word = 'Python'
>>> word[0]  # 位置0の文字
'P'
>>> word[5]  # 位置5の文字
'n'
```

**負のインデックス:**
- 右から数えることもできる!

```python
>>> word[-1]  # 最後の文字
'n'
>>> word[-2]  # 最後から2番目の文字
'o'
>>> word[-6]
'P'
```

**注意:** `-0` は `0` と同じだから、負のインデックスは `-1` から始まるよ。

#### スライス

**インデックス = 個別の文字を取得**
**スライス = 部分文字列を取得**

```python
>>> word[0:2]  # 位置0(含む)から2(含まない)
'Py'
>>> word[2:5]  # 位置2(含む)から5(含まない)
'tho'
```

**便利なデフォルト値:**
- 最初のインデックスを省略 → `0` がデフォルト
- 2番目のインデックスを省略 → 文字列のサイズがデフォルト

```python
>>> word[:2]   # 最初から位置2(含まない)
'Py'
>>> word[4:]   # 位置4(含む)から最後まで
'on'
>>> word[-2:]  # 最後から2番目(含む)から最後まで
'on'
```

**重要なルール:**
- 開始位置は**常に含まれる**
- 終了位置は**常に含まれない**
- だから `s[:i] + s[i:]` は常に `s` と等しくなる!

```python
>>> word[:2] + word[2:]
'Python'
>>> word[:4] + word[4:]
'Python'
```

#### スライスの仕組みを理解する

**インデックスは文字の「間」を指してる**と考えよう:
- 最初の文字の左端が `0`
- n文字の文字列の最後の文字の右端が `n`

```
 +---+---+---+---+---+---+
 | P | y | t | h | o | n |
 +---+---+---+---+---+---+
 0   1   2   3   4   5   6
-6  -5  -4  -3  -2  -1
```

- **1行目**: 正のインデックス 0〜6
- **2行目**: 対応する負のインデックス
- **i から j へのスライス** = ラベル i と j の間のすべての文字

**非負のインデックスの場合:**
- スライスの長さ = インデックスの差(両方が範囲内の場合)
- 例: `word[1:3]` の長さは `2`

#### インデックスエラー

**大きすぎるインデックスを使うとエラー:**

```python
>>> word[42]  # wordは6文字しかない
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: string index out of range
```

**でも、範囲外のスライスインデックスは優雅に処理される:**

```python
>>> word[4:42]
'on'
>>> word[42:]
''
```

#### 文字列の不変性(Immutable)

**Python文字列は変更できない = イミュータブル**

だから、インデックス位置に代入しようとするとエラー:

```python
>>> word[0] = 'J'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment

>>> word[2:] = 'py'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
```

**別の文字列が必要な時は、新しく作る:**

```python
>>> 'J' + word[1:]
'Jython'
>>> word[:2] + 'py'
'Pypy'
```

#### 文字列の長さ

組み込み関数 `len()` で文字列の長さを取得:

```python
>>> s = 'supercalifragilisticexpialidocious'
>>> len(s)
34
```

#### もっと知りたい人へ

- **テキストシーケンス型 — str**: 文字列はシーケンス型の例で、共通操作をサポート
- **文字列メソッド**: 基本的な変換や検索のための多数のメソッド
- **フォーマット済み文字列リテラル**: 式を埋め込んだ文字列リテラル
- **書式文字列構文**: `str.format()` での文字列フォーマット
- **printf スタイルの文字列フォーマット**: `%` 演算子を使った古いフォーマット

### 3.1.3. リスト

Pythonには、複数の値をグループ化するための**複合データ型**がいくつかあるよ。

一番汎用性が高いのが**リスト**!

**リストの書き方:**
- カンマ区切りの値(項目)を角括弧 `[]` で囲む
- 異なる型の項目を含めることもできるけど、通常は同じ型

```python
>>> squares = [1, 4, 9, 16, 25]
>>> squares
[1, 4, 9, 16, 25]
```

#### リストのインデックスとスライス

文字列(や他の組み込みシーケンス型)と同様に、リストもインデックスとスライスができる:

```python
>>> squares[0]  # インデックス → 項目を返す
1
>>> squares[-1]
25
>>> squares[-3:]  # スライス → 新しいリストを返す
[9, 16, 25]
```

**重要:**
- すべてのスライス操作は、要求された要素を含む**新しいリスト**を返す
- つまり、以下のスライスはリストの**シャローコピー**を返す:

```python
>>> squares[:]
[1, 4, 9, 16, 25]
```

#### リストの連結

リストも連結操作をサポート:

```python
>>> squares + [36, 49, 64, 81, 100]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```

#### リストの可変性(Mutable)

**文字列はイミュータブル(変更不可)だけど、リストはミュータブル(変更可能)!**

つまり、内容を変更できる:

```python
>>> cubes = [1, 8, 27, 65, 125]  # 何か間違ってる
>>> 4 ** 3  # 4の3乗は64で、65じゃない!
64
>>> cubes[3] = 64  # 間違った値を置き換える
>>> cubes
[1, 8, 27, 64, 125]
```

#### append()メソッド

リストの末尾に新しい項目を追加できる(メソッドについては後で詳しくやるよ):

```python
>>> cubes.append(216)  # 6の3乗を追加
>>> cubes.append(7 ** 3)  # 7の3乗を追加
>>> cubes
[1, 8, 27, 64, 125, 216, 343]
```

#### スライスへの代入

スライスへの代入も可能!これでリストのサイズを変更したり、完全にクリアしたりできる:

```python
>>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
>>> letters
['a', 'b', 'c', 'd', 'e', 'f', 'g']

>>> # いくつかの値を置き換え
>>> letters[2:5] = ['C', 'D', 'E']
>>> letters
['a', 'b', 'C', 'D', 'E', 'f', 'g']

>>> # それらを削除
>>> letters[2:5] = []
>>> letters
['a', 'b', 'f', 'g']

>>> # すべての要素を空リストで置き換えてクリア
>>> letters[:] = []
>>> letters
[]
```

#### リストの長さ

組み込み関数 `len()` はリストにも使える:

```python
>>> letters = ['a', 'b', 'c', 'd']
>>> len(letters)
4
```

#### リストのネスト(入れ子)

リストの中にリストを含めることもできる!

```python
>>> a = ['a', 'b', 'c']
>>> n = [1, 2, 3]
>>> x = [a, n]
>>> x
[['a', 'b', 'c'], [1, 2, 3]]
>>> x[0]
['a', 'b', 'c']
>>> x[0][1]
'b'
```

## 3.2. プログラミングへの最初の一歩

もちろん、Pythonは「2 + 2」みたいな単純な計算以上のことができるよ!

例えば、**フィボナッチ数列**の初期部分列を書くことができる:

```python
>>> # フィボナッチ数列:
... # 2つの要素の合計が次を定義する
... a, b = 0, 1
>>> while a < 10:
...     print(a)
...     a, b = b, a+b
...
0
1
1
2
3
5
8
```

この例では、いくつか新しい機能が登場してるよ。

### 1. 多重代入

**最初の行に多重代入がある:**
- 変数 `a` と `b` が同時に新しい値 `0` と `1` を取得
- 最後の行でも使われてる

**評価順序:**
- 右辺の式が**すべて先に評価**されてから代入が行われる
- 右辺の式は左から右へ評価される

### 2. whileループ

`while` ループは、条件(ここでは `a < 10`)が真である限り実行される。

**Pythonの真偽値:**
- Cと同様に、**ゼロ以外の整数値 = 真**
- **ゼロ = 偽**
- 条件は文字列やリストの値でもOK(実際には任意のシーケンス)
- **長さがゼロ以外 = 真**
- **空のシーケンス = 偽**

**この例で使われてるテスト = 単純な比較**

**標準の比較演算子(Cと同じ書き方):**
- `<` (より小さい)
- `>` (より大きい)
- `==` (等しい)
- `<=` (以下)
- `>=` (以上)
- `!=` (等しくない)

### 3. インデント

**ループの本体はインデントされてる:**
- **インデント = Pythonの文のグループ化方法**

**対話的プロンプトでの入力:**
- インデントされた行ごとに、タブかスペースを入力する必要がある
- 実際には、テキストエディタで複雑な入力を準備することになる
- まともなエディタはすべて自動インデント機能を持ってる

**複合文を対話的に入力する時:**
- 完了を示すために空行を続ける必要がある(パーサーが最後の行を推測できないから)
- 基本ブロック内の各行は、同じ量だけインデントする必要がある

### 4. print()関数

`print()` 関数は、与えられた引数の値を書き出す。

**式をそのまま書くのとの違い:**
(電卓の例でやったように)
- 複数の引数の扱い方
- 浮動小数点数の扱い方
- 文字列の扱い方

**print()の特徴:**
- 文字列はクォートなしで表示
- 項目間にスペースが挿入される
- だからきれいにフォーマットできる

```python
>>> i = 256*256
>>> print('The value of i is', i)
The value of i is 65536
```

**キーワード引数 `end`:**
- 出力後の改行を避けられる
- 別の文字列で出力を終わらせることもできる

```python
>>> a, b = 0, 1
>>> while a < 1000:
...     print(a, end=',')
...     a, b = b, a+b
...
0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,
```

## 脚注

**1. べき乗演算子の優先度:**
`**` は `-` より優先度が高いから:
- `-3**2` は `-(3**2)` と解釈されて `-9` になる
- `9` が欲しい時は `(-3)**2` を使おう

**2. クォート内の特殊文字:**
他の言語と違って、`\n` みたいな特殊文字はシングルクォート `'...'` でもダブルクォート `"..."` でも同じ意味。

唯一の違い:
- シングルクォート内では `"` をエスケープ不要(でも `\'` はエスケープ必要)
- 逆もまた然り

---

この章で、Pythonの基本的な使い方がわかったね!( ˶'ᵕ'˶)
次の章からは、もっと本格的なプログラミングに入っていくよ〜✨
<!-- claude_translate/tutorial_015.md -->

# 15. 浮動小数点演算：問題と制限

## 浮動小数点数の基礎

浮動小数点数は、コンピュータのハードウェアでは**2進数（base 2）の分数**として表現されます。

**例：**
- 10進数の分数 `0.125` は、値が 1/10 + 2/100 + 5/1000
- 同じように、2進数の分数 `0.001` は、値が 0/2 + 0/4 + 1/8

これら2つの分数は同じ値を持っていて、唯一の違いは、最初が10進数表記で書かれていて、2番目が2進数表記で書かれているということだけです。

## 問題：10進数を正確に表現できない

残念ながら、**ほとんどの10進数の分数は、2進数の分数として正確に表現できません**。

その結果、一般的に、入力した10進数の浮動小数点数は、実際にマシンに保存される2進数の浮動小数点数によって**近似されるだけ**です。

### 10進数で考えてみよう

この問題は、最初は10進数で考えた方が理解しやすいです。分数 1/3 を考えてみましょう。

10進数の分数として近似すると：
- `0.3`
- もっと良くすると `0.33`
- さらに良くすると `0.333`
- というように続きます

**何桁書いても、結果は決して正確に 1/3 にはなりません**が、1/3 のますます良い近似値になります。

### 2進数でも同じ問題が起きる

同じように、何桁の2進数を使っても、**10進数の値 0.1 は2進数の分数として正確に表現できません**。

2進数では、1/10 は無限に繰り返す分数になります：

```
0.0001100110011001100110011001100110011001100110011...
```

有限のビット数で止めれば、近似値しか得られません。

現在のほとんどのマシンでは、floatは次のように近似されます：
- 分子：最上位ビットから始まる最初の53ビットを使用
- 分母：2のべき乗

1/10 の場合、2進数の分数は `3602879701896397 / 2 ** 55` となり、1/10 の真の値に**近いですが、正確には等しくありません**。

---

## なぜ気づかないの？

多くのユーザーは、値の表示方法のために近似に気づいていません。

Pythonは、マシンが保存する2進数近似値の真の10進数値に対して、**10進数の近似値のみを表示**します。

ほとんどのマシンで、Pythonが0.1に保存される2進数近似値の真の10進数値を表示すると、次のようになります：

```python
>>> 0.1
0.1000000000000000055511151231257827021181583404541015625
```

これはほとんどの人にとって有用な桁数より多いので、**Pythonは丸めた値を表示することで桁数を管理可能にしています**：

```python
>>> 1 / 10
0.1
```

**覚えておいて！** 表示された結果は 1/10 の正確な値のように見えますが、実際に保存されている値は、**最も近い表現可能な2進数の分数**です。

### 同じ近似値を共有する10進数

興味深いことに、**同じ最も近い近似2進数分数を共有する異なる10進数がたくさん**あります。

例えば、以下の数値はすべて `3602879701896397 / 2 ** 55` で近似されます：
- `0.1`
- `0.10000000000000001`
- `0.1000000000000000055511151231257827021181583404541015625`

これらすべての10進数値は同じ近似を共有しているので、`eval(repr(x)) == x` の不変条件を維持しながら、そのうちの**どれを表示してもOK**です。

歴史的に、Pythonプロンプトと組み込み`repr()`関数は、17桁の有効数字を持つもの `0.10000000000000001` を選択していました。Python 3.1以降、Python（ほとんどのシステムで）は、これらの中で**最も短いものを選択**し、単に `0.1` を表示できるようになりました。

---

## これはバグじゃない！

**注意：** これは2進数浮動小数点の本質的な性質です。これはPythonのバグではなく、あなたのコードのバグでもありません。

ハードウェアの浮動小数点演算をサポートする**すべての言語で同じことが起こります**（ただし、一部の言語はデフォルトで、またはすべての出力モードで差を表示しないかもしれません）。

---

## より見やすい出力にするには

より見やすい出力にするには、文字列フォーマットを使用して限られた桁数の有効数字を生成できます：

```python
>>> format(math.pi, '.12g')  # 12桁の有効数字
'3.14159265359'

>>> format(math.pi, '.2f')   # 小数点以下2桁
'3.14'

>>> repr(math.pi)
'3.141592653589793'
```

**重要：** これは本当の意味で**幻想**であることを理解することが重要です。単に真のマシン値の表示を丸めているだけです。

---

## 幻想が別の幻想を生む

1つの幻想が別の幻想を生むことがあります。

例えば、0.1 は正確に 1/10 ではないので、0.1 の3つの値を合計しても、正確に 0.3 にならない可能性があります：

```python
>>> .1 + .1 + .1 == .3
False
```

また、0.1 は 1/10 の正確な値にこれ以上近づけず、0.3 は 3/10 の正確な値にこれ以上近づけないので、`round()`関数で事前に丸めても役に立ちません：

```python
>>> round(.1, 1) + round(.1, 1) + round(.1, 1) == round(.3, 1)
False
```

### 事後丸めは有効

数値を意図した正確な値に近づけることはできませんが、`round()`関数は**事後丸め**に役立ち、不正確な値を持つ結果を互いに比較可能にします：

```python
>>> round(.1 + .1 + .1, 10) == round(.3, 10)
True
```

---

## 浮動小数点演算の驚き

2進数浮動小数点演算には、このような驚きがたくさんあります。「0.1」の問題は、以下の「表現エラー」セクションで詳しく説明されています。

他の一般的な驚きのより完全な説明については、[The Perils of Floating Point](https://www.lahey.com/float.htm) を参照してください。

そこで最後に言っているように、「簡単な答えはありません」。それでも、浮動小数点を過度に警戒しないでください！

### エラーの大きさ

Python floatの演算のエラーは、浮動小数点ハードウェアから継承されており、ほとんどのマシンでは**演算ごとに 2**53 分の1以下**です。

これはほとんどのタスクには十分ですが、**10進数演算ではない**こと、そして**すべてのfloat演算が新しい丸めエラーを被る可能性がある**ことを覚えておく必要があります。

### 通常の使用では問題ない

病的なケースは存在しますが、浮動小数点演算のほとんどのカジュアルな使用では、**最終結果の表示を期待する10進数の桁数に丸める**だけで、最終的に期待する結果が得られます。

`str()`で通常は十分で、より細かい制御には`str.format()`メソッドのフォーマット指定子を参照してください。

---

## 正確な10進数表現が必要な場合

### decimalモジュール

正確な10進数表現が必要なユースケースには、`decimal`モジュールを試してください。これは、**会計アプリケーションや高精度アプリケーション**に適した10進数演算を実装しています。

### fractionsモジュール

別の形式の正確な演算は、`fractions`モジュールでサポートされています。これは**有理数に基づく演算**を実装しているので、1/3 のような数値を正確に表現できます。

### NumPy

浮動小数点演算のヘビーユーザーなら、**NumPyパッケージ**と、SciPyプロジェクトが提供する数学および統計演算用の他の多くのパッケージを見てください。https://scipy.org を参照。

---

## floatの正確な値を知るツール

Pythonは、floatの正確な値を本当に知りたいまれな場合に役立つツールを提供しています。

### float.as_integer_ratio()

`float.as_integer_ratio()`メソッドは、floatの値を分数として表現します：

```python
>>> x = 3.14159
>>> x.as_integer_ratio()
(3537115888337719, 1125899906842624)
```

比率は正確なので、元の値を損失なく再現するために使用できます：

```python
>>> x == 3537115888337719 / 1125899906842624
True
```

### float.hex()

`float.hex()`メソッドは、floatを**16進数（base 16）**で表現し、コンピュータが保存する正確な値を示します：

```python
>>> x.hex()
'0x1.921f9f01b866ep+1'
```

この正確な16進数表現を使用して、float値を正確に再構築できます：

```python
>>> x == float.fromhex('0x1.921f9f01b866ep+1')
True
```

表現は正確なので、異なるバージョンのPython間で値を確実に移植したり（プラットフォーム独立性）、同じフォーマットをサポートする他の言語（JavaやC99など）とデータを交換したりするのに役立ちます。

### math.fsum()

もう1つの役立つツールは、`math.fsum()`関数です。これは**合計中の精度の損失を軽減**するのに役立ちます。

値が実行中の合計に追加されるときに「失われた桁」を追跡します。これにより、エラーが最終合計に影響するポイントまで蓄積しないように、全体的な精度に違いが生じる可能性があります：

```python
>>> sum([0.1] * 10) == 1.0
False
>>> math.fsum([0.1] * 10) == 1.0
True
```

めっちゃ便利だよね！( ˶'ᵕ'˶)

---

## 15.1. 表現エラー

このセクションでは、「0.1」の例を詳しく説明し、このようなケースを自分で正確に分析する方法を示します。2進数浮動小数点表現の基本的な知識を前提としています。

### 表現エラーとは

**表現エラー**とは、一部の（実際にはほとんどの）10進数の分数が、2進数（base 2）の分数として正確に表現できないという事実を指します。

これが、Python（またはPerl、C、C++、Java、Fortranなど）が期待する正確な10進数を表示しないことが多い**主な理由**です。

### なぜ？

1/10 は2進数の分数として正確に表現できません。

現在のほぼすべてのマシン（2000年11月）は**IEEE-754浮動小数点演算**を使用し、ほぼすべてのプラットフォームがPython floatをIEEE-754「倍精度」にマップします。

754倍精度には**53ビットの精度**が含まれているので、入力時にコンピュータは0.1を、正確に53ビットを含む整数Jを使って、`J/2**N`の形式の最も近い分数に変換しようとします。

書き直すと：
```
1 / 10 ~= J / (2**N)
```

つまり：
```
J ~= 2**N / 10
```

Jが正確に53ビット（`>= 2**52` だが `< 2**53`）であることを思い出すと、Nの最適値は**56**です：

```python
>>> 2**52 <= 2**56 // 10 < 2**53
True
```

つまり、56はJを正確に53ビットのままにする唯一のNの値です。

Jの最良の可能な値は、その商を丸めたものです：

```python
>>> q, r = divmod(2**56, 10)
>>> r
6
```

余りは10の半分以上なので、**切り上げ**によって最良の近似が得られます：

```python
>>> q+1
7205759403792794
```

したがって、754倍精度における1/10の最良の近似は：

```
7205759403792794 / 2 ** 56
```

分子と分母の両方を2で割ると、分数は次のようになります：

```
3602879701896397 / 2 ** 55
```

**注意：** 切り上げたので、これは実際には1/10より**わずかに大きい**です。切り上げなかった場合、商は1/10より**わずかに小さく**なっていたでしょう。しかし、**どちらの場合も正確に1/10にはなりません**！

### コンピュータが「見ている」もの

コンピュータは決して1/10を「見ません」。コンピュータが見ているのは、上記の正確な分数、つまり得られる最良の754倍精度近似です：

```python
>>> 0.1 * 2 ** 55
3602879701896397.0
```

その分数に10**55を掛けると、55桁の10進数で値を見ることができます：

```python
>>> 3602879701896397 * 10 ** 55 // 2 ** 55
1000000000000000055511151231257827021181583404541015625
```

つまり、コンピュータに保存されている正確な数値は、10進数値 **0.1000000000000000055511151231257827021181583404541015625** に等しいということです。

完全な10進数値を表示する代わりに、多くの言語（古いバージョンのPythonを含む）は、結果を**17桁の有効数字に丸めます**：

```python
>>> format(0.1, '.17f')
'0.10000000000000001'
```

---

## fractionsとdecimalモジュールでの計算

`fractions`と`decimal`モジュールを使うと、これらの計算が簡単になります：

```python
>>> from decimal import Decimal
>>> from fractions import Fraction

>>> Fraction.from_float(0.1)
Fraction(3602879701896397, 36028797018963968)

>>> (0.1).as_integer_ratio()
(3602879701896397, 36028797018963968)

>>> Decimal.from_float(0.1)
Decimal('0.1000000000000000055511151231257827021181583404541015625')

>>> format(Decimal.from_float(0.1), '.17')
'0.10000000000000001'
```

---

## 📝 重要ポイントまとめ

### 1. 浮動小数点数の本質
- **2進数で表現**: コンピュータ内部では2進数の分数として保存される
- **近似値**: ほとんどの10進数は2進数で正確に表現できない
- **0.1の例**: 0.1は内部的には `3602879701896397 / 2 ** 55` として保存される

### 2. よくある誤解
- 画面に「0.1」と表示されても、内部的には正確に0.1ではない
- これは**Pythonのバグではない** - すべての言語で同じ
- 表示は丸められた値

### 3. 浮動小数点の問題例
```python
# 加算の誤差
.1 + .1 + .1 == .3  # False

# 事前丸めは効かない
round(.1, 1) + round(.1, 1) + round(.1, 1) == round(.3, 1)  # False

# 事後丸めは効く
round(.1 + .1 + .1, 10) == round(.3, 10)  # True
```

### 4. 対処方法

| 用途             | ツール                | 説明               |
| ---------------- | --------------------- | ------------------ |
| 会計・高精度計算 | `decimal`モジュール   | 正確な10進数演算   |
| 分数計算         | `fractions`モジュール | 有理数として表現   |
| 精度の高い合計   | `math.fsum()`         | 誤差を軽減した合計 |
| 科学計算         | NumPy/SciPy           | 高度な数値計算     |

### 5. 便利な関数・メソッド

```python
# 正確な比率を取得
x.as_integer_ratio()  # (分子, 分母)のタプル

# 16進数表現（正確な値）
x.hex()  # '0x1.921f9f01b866ep+1'

# 16進数から復元
float.fromhex('0x1.921f9f01b866ep+1')

# 精度を保った合計
math.fsum([0.1] * 10)  # 1.0
```

### 6. 試験対策で特に重要
1. **浮動小数点数は近似値**であることを理解
2. **0.1 + 0.1 + 0.1 != 0.3** になる理由
3. `decimal`モジュールは正確な10進数演算用
4. `fractions`モジュールは有理数を正確に表現
5. `math.fsum()`は精度を保った合計
6. これは**バグではなく、浮動小数点の性質**

### 覚えておくべきこと
- 浮動小数点は**2進数で近似**される
- 金融計算など正確性が必要なら`decimal`を使う
- 分数計算には`fractions`を使う
- 通常の計算では丸め誤差を意識する
- `math.fsum()`で合計の精度を向上

これで浮動小数点の問題と対処法はバッチリだね！試験でも実務でも重要な知識だよ( ˶'ᵕ'˶)♡
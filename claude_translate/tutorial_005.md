<!-- claude_translate/tutorial_005.md -->

# 5. データ構造

この章では、既に学んだことをもっと詳しく説明して、新しいこともいくつか追加するよ。

## 5.1. リストについてもっと

リストデータ型にはもっとメソッドがある。リストオブジェクトのすべてのメソッド:

### リストのメソッド一覧

**`list.append(x)`**
- リストの最後に項目を追加
- `a[len(a):] = [x]` と同等

**`list.extend(iterable)`**
- iterableからすべての項目を追加してリストを拡張
- `a[len(a):] = iterable` と同等

**`list.insert(i, x)`**
- 指定位置に項目を挿入
- 最初の引数は、その前に挿入する要素のインデックス
- `a.insert(0, x)` はリストの先頭に挿入
- `a.insert(len(a), x)` は `a.append(x)` と同等

**`list.remove(x)`**
- 値が x と等しい最初の項目をリストから削除
- そのような項目がない場合は `ValueError` を発生

**`list.pop([i])`**
- リスト内の指定位置の項目を削除して返す
- インデックスが指定されてない場合、`a.pop()` は最後の項目を削除して返す
- (メソッドシグネチャの i の周りの角括弧は、パラメータがオプションであることを示す。実際に角括弧を入力するわけじゃないよ。Python Library Referenceでこの表記をよく見るよ)

**`list.clear()`**
- リストからすべての項目を削除
- `del a[:]` と同等

**`list.index(x[, start[, end]])`**
- 値が x と等しい最初の項目の0ベースのインデックスを返す
- そのような項目がない場合は `ValueError` を発生
- オプション引数 start と end はスライス記法のように解釈される
- 検索をリストの特定の部分列に制限するために使う
- 返されるインデックスは、start 引数じゃなく、完全なシーケンスの先頭から計算される

**`list.count(x)`**
- リスト内に x が現れる回数を返す

**`list.sort(*, key=None, reverse=False)`**
- リストの項目をその場でソート
- 引数はソートのカスタマイズに使える(詳しくは `sorted()` を見てね)

**`list.reverse()`**
- リストの要素をその場で逆順にする

**`list.copy()`**
- リストのシャローコピーを返す
- `a[:]` と同等

### 使用例

リストメソッドのほとんどを使った例:

```python
>>> fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana']
>>> fruits.count('apple')
2
>>> fruits.count('tangerine')
0
>>> fruits.index('banana')
3
>>> fruits.index('banana', 4)  # 位置4から次のバナナを探す
6
>>> fruits.reverse()
>>> fruits
['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange']
>>> fruits.append('grape')
>>> fruits
['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape']
>>> fruits.sort()
>>> fruits
['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear']
>>> fruits.pop()
'pear'
```

### 重要な設計原則

**`insert`、`remove`、`sort` のようなメソッド:**
- リストを変更するだけ
- 戻り値が表示されない
- デフォルトの `None` を返す

**これはPythonのすべてのミュータブルデータ構造の設計原則!**

**もう1つ気づくこと:**
- すべてのデータがソートや比較できるわけじゃない
- 例: `[None, 'hello', 10]` はソートできない
  - 整数と文字列を比較できない
  - `None` は他の型と比較できない
- 定義された順序関係がない型もある
  - 例: `3+4j < 5+7j` は有効な比較じゃない

## 5.1.1. リストをスタックとして使う

リストメソッドを使えば、スタックとして簡単に使える。

**スタック = 「後入れ先出し」(Last-In, First-Out)**
- 最後に追加した要素が最初に取り出される

**操作:**
- スタックの上に項目を追加: `append()` を使う
- スタックの上から項目を取り出す: インデックスなしの `pop()` を使う

**例:**
```python
>>> stack = [3, 4, 5]
>>> stack.append(6)
>>> stack.append(7)
>>> stack
[3, 4, 5, 6, 7]
>>> stack.pop()
7
>>> stack
[3, 4, 5, 6]
>>> stack.pop()
6
>>> stack.pop()
5
>>> stack
[3, 4]
```

## 5.1.2. リストをキューとして使う

**キュー = 「先入れ先出し」(First-In, First-Out)**
- 最初に追加した要素が最初に取り出される

**問題点:**
- リストをキューとして使うことも可能だけど、効率的じゃない
- リストの末尾への追加と取り出しは速い
- **リストの先頭への挿入や取り出しは遅い**(他のすべての要素を1つずつシフトする必要があるから)

**解決策: `collections.deque` を使う**
- 両端からの高速な追加と取り出しのために設計されてる

**例:**
```python
>>> from collections import deque
>>> queue = deque(["Eric", "John", "Michael"])
>>> queue.append("Terry")           # Terryが到着
>>> queue.append("Graham")          # Grahamが到着
>>> queue.popleft()                 # 最初に到着した人が去る
'Eric'
>>> queue.popleft()                 # 2番目に到着した人が去る
'John'
>>> queue                           # 到着順に残ってるキュー
deque(['Michael', 'Terry', 'Graham'])
```

## 5.1.3. リスト内包表記

**リスト内包表記 = リストを作る簡潔な方法**

**一般的な用途:**
- 別のシーケンスやiterableの各メンバーに操作を適用した結果の新しいリストを作る
- 特定の条件を満たす要素の部分列を作る

**例: 平方のリストを作りたい**

**従来の方法:**
```python
>>> squares = []
>>> for x in range(10):
...     squares.append(x**2)
...
>>> squares
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

**注意:** これは `x` という名前の変数を作る(またはオーバーライトする)。ループ完了後も存在し続ける。

**副作用なしで計算:**

**方法1: map()とlambdaを使う**
```python
squares = list(map(lambda x: x**2, range(10)))
```

**方法2: リスト内包表記(より簡潔で読みやすい!)**
```python
squares = [x**2 for x in range(10)]
```

### リスト内包表記の構文

**構成:**
- 角括弧内に式を含む
- その後に `for` 節
- 次に0個以上の `for` または `if` 節

**結果:**
- `for` と `if` 節のコンテキストで式を評価した結果の新しいリスト

**例: 2つのリストの要素を組み合わせる(等しくない場合)**
```python
>>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
```

**これは以下と同等:**
```python
>>> combs = []
>>> for x in [1,2,3]:
...     for y in [3,1,4]:
...         if x != y:
...             combs.append((x, y))
...
>>> combs
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
```

**注意:** 両方のスニペットで `for` と `if` 文の順序が同じ!

**式がタプルの場合(例: `(x, y)`)、括弧で囲む必要がある**

### リスト内包表記の例いろいろ

**値を2倍にする:**
```python
>>> vec = [-4, -2, 0, 2, 4]
>>> [x*2 for x in vec]
[-8, -4, 0, 4, 8]
```

**負の数を除外:**
```python
>>> [x for x in vec if x >= 0]
[0, 2, 4]
```

**すべての要素に関数を適用:**
```python
>>> [abs(x) for x in vec]
[4, 2, 0, 2, 4]
```

**各要素のメソッドを呼ぶ:**
```python
>>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']
>>> [weapon.strip() for weapon in freshfruit]
['banana', 'loganberry', 'passion fruit']
```

**2タプルのリストを作成:**
```python
>>> [(x, x**2) for x in range(6)]
[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]
```

**タプルは括弧で囲む必要がある(じゃないとエラー):**
```python
>>> [x, x**2 for x in range(6)]
  File "<stdin>", line 1
    [x, x**2 for x in range(6)]
             ^
SyntaxError: invalid syntax
```

**リストをフラット化(2つのforを使う):**
```python
>>> vec = [[1,2,3], [4,5,6], [7,8,9]]
>>> [num for elem in vec for num in elem]
[1, 2, 3, 4, 5, 6, 7, 8, 9]
```

**複雑な式とネストした関数も使える:**
```python
>>> from math import pi
>>> [str(round(pi, i)) for i in range(1, 6)]
['3.1', '3.14', '3.142', '3.1416', '3.14159']
```

## 5.1.4. ネストしたリスト内包表記

リスト内包表記の最初の式は、任意の式でOK。別のリスト内包表記も含む!

**例: 3x4行列を転置する**

3つの長さ4のリストのリストとして実装された行列:
```python
>>> matrix = [
...     [1, 2, 3, 4],
...     [5, 6, 7, 8],
...     [9, 10, 11, 12],
... ]
```

**行と列を転置するリスト内包表記:**
```python
>>> [[row[i] for row in matrix] for i in range(4)]
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
```

**これは以下と同等:**
```python
>>> transposed = []
>>> for i in range(4):
...     transposed.append([row[i] for row in matrix])
...
>>> transposed
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
```

**さらに展開すると:**
```python
>>> transposed = []
>>> for i in range(4):
...     # 以下の3行がネストしたリスト内包表記を実装
...     transposed_row = []
...     for row in matrix:
...         transposed_row.append(row[i])
...     transposed.append(transposed_row)
...
>>> transposed
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
```

**実際には、複雑なフロー文より組み込み関数を優先すべき!**

`zip()` 関数がこのユースケースに最適:
```python
>>> list(zip(*matrix))
[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]
```

この行のアスタリスクについては、「引数リストのアンパック」を見てね。

## 5.2. del文

**値じゃなくインデックスでリストから項目を削除する方法: `del` 文**

**`pop()` メソッドとの違い:**
- `pop()` は値を返す
- `del` は値を返さない

**`del` 文でできること:**
- リストからスライスを削除
- リスト全体をクリア(以前、空リストをスライスに代入してやったやつ)

**例:**
```python
>>> a = [-1, 1, 66.25, 333, 333, 1234.5]
>>> del a[0]
>>> a
[1, 66.25, 333, 333, 1234.5]
>>> del a[2:4]
>>> a
[1, 66.25, 1234.5]
>>> del a[:]
>>> a
[]
```

**変数全体を削除することもできる:**
```python
>>> del a
```

その後 `a` という名前を参照するのはエラー(少なくとも別の値が代入されるまで)。

`del` の他の用途は後で見つかるよ!

## 5.3. タプルとシーケンス

**リストと文字列の共通特性:**
- インデックス操作
- スライス操作

これらは**シーケンスデータ型**の2つの例。Pythonは進化する言語だから、他のシーケンスデータ型が追加されるかも。

**もう1つの標準シーケンスデータ型: タプル**

### タプルの基本

**タプル = カンマで区切られた複数の値**

```python
>>> t = 12345, 54321, 'hello!'
>>> t[0]
12345
>>> t
(12345, 54321, 'hello!')
```

**タプルのネストも可能:**
```python
>>> u = t, (1, 2, 3, 4, 5)
>>> u
((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))
```

**タプルはイミュータブル(変更不可):**
```python
>>> t[0] = 88888
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
```

**でもミュータブルなオブジェクトを含められる:**
```python
>>> v = ([1, 2, 3], [3, 2, 1])
>>> v
([1, 2, 3], [3, 2, 1])
```

### タプルの表示と入力

**出力:**
- タプルは常に括弧で囲まれて表示される
- ネストしたタプルが正しく解釈されるように

**入力:**
- 括弧ありでもなしでもOK
- ただし、タプルがより大きい式の一部の場合は括弧が必要なことが多い

**制限:**
- タプルの個別項目に代入できない
- ミュータブルなオブジェクト(リストなど)を含むタプルは作れる

### タプルとリストの使い分け

**タプル:**
- イミュータブル
- 通常、異種要素のシーケンスを含む
- アンパックまたはインデックスでアクセス(namedtuplesの場合は属性でも)

**リスト:**
- ミュータブル
- 要素は通常同種
- リストを繰り返してアクセス

### 特殊な構文

**0個または1個の項目を含むタプル:**

**空のタプル:**
```python
>>> empty = ()
>>> len(empty)
0
```

**1項目のタプル(末尾のカンマに注目!):**
```python
>>> singleton = 'hello',    # <-- 末尾のカンマに注目
>>> len(singleton)
1
>>> singleton
('hello',)
```

単一の値を括弧で囲むだけでは不十分。醜いけど効果的!

### タプルのパッキングとアンパッキング

**タプルパッキング:**
```python
>>> t = 12345, 54321, 'hello!'
```

値 `12345`、`54321`、`'hello!'` がタプルにパックされる。

**シーケンスアンパッキング(逆の操作):**
```python
>>> x, y, z = t
```

右辺の任意のシーケンスで動く。

**要件:**
- 等号の左側の変数の数 = シーケンスの要素数

**注意:** 多重代入は、タプルパッキングとシーケンスアンパッキングの組み合わせ!

## 5.4. セット

**セット = 重複要素のない順序なしコレクション**

**基本的な用途:**
- メンバーシップテスト
- 重複エントリの削除

**セットオブジェクトは数学的演算もサポート:**
- 和集合(union)
- 積集合(intersection)
- 差集合(difference)
- 対称差(symmetric difference)

### セットの作成

**中括弧または `set()` 関数:**
```python
>>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
>>> print(basket)                      # 重複が削除されてる
{'orange', 'banana', 'pear', 'apple'}
```

**注意:**
- 空のセットを作るには `set()` を使う
- `{}` は使えない(これは空の辞書を作る)

### セット操作の例

**メンバーシップテスト:**
```python
>>> 'orange' in basket                 # 高速なメンバーシップテスト
True
>>> 'crabgrass' in basket
False
```

**2つの単語のユニークな文字でセット演算:**
```python
>>> a = set('abracadabra')
>>> b = set('alacazam')
>>> a                                  # aのユニークな文字
{'a', 'r', 'b', 'c', 'd'}
>>> a - b                              # aにあってbにない文字
{'r', 'd', 'b'}
>>> a | b                              # aまたはbまたは両方にある文字
{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}
>>> a & b                              # aとb両方にある文字
{'a', 'c'}
>>> a ^ b                              # aまたはbにあるが両方にはない文字
{'r', 'd', 'b', 'm', 'z', 'l'}
```

### セット内包表記

リスト内包表記と同様に、セット内包表記もサポート:

```python
>>> a = {x for x in 'abracadabra' if x not in 'abc'}
>>> a
{'r', 'd'}
```

## 5.5. 辞書

**辞書 = Pythonに組み込まれた便利なデータ型**

他の言語では「連想メモリ」や「連想配列」と呼ばれることもある。

### シーケンスとの違い

**シーケンス:**
- 数値の範囲でインデックス化

**辞書:**
- **キー**でインデックス化
- キーは任意のイミュータブル型
- 文字列と数値は常にキーになれる
- タプルも、文字列、数値、タプルのみを含む場合はキーになれる
  - ミュータブルなオブジェクトを直接的または間接的に含む場合は使えない
- リストはキーとして使えない
  - インデックス代入、スライス代入、`append()` や `extend()` メソッドで変更できるから

### 辞書の概念

**辞書 = キー:値のペアの集合**
- キーは(1つの辞書内で)一意でないといけない

**空の辞書:**
- 1対の中括弧 `{}` で作成

**初期キー:値ペアの追加:**
- 中括弧内にカンマ区切りのキー:値ペアのリストを配置
- これは辞書の出力方法でもある

### 辞書の主な操作

**値の格納:**
- キーで値を格納

**値の取得:**
- キーで値を取得

**キー:値ペアの削除:**
- `del` を使う

**既に使われてるキーで格納:**
- そのキーに関連付けられた古い値は忘れられる

**存在しないキーで値を取得:**
- エラー

### その他の操作

**辞書のすべてのキーのリストを返す:**
```python
list(d)
```
- 挿入順で返される
- ソート済みが欲しい場合は `sorted(d)` を使う

**辞書に単一のキーがあるかチェック:**
- `in` キーワードを使う

### 辞書の使用例

```python
>>> tel = {'jack': 4098, 'sape': 4139}
>>> tel['guido'] = 4127
>>> tel
{'jack': 4098, 'sape': 4139, 'guido': 4127}
>>> tel['jack']
4098
>>> del tel['sape']
>>> tel['irv'] = 4127
>>> tel
{'jack': 4098, 'guido': 4127, 'irv': 4127}
>>> list(tel)
['jack', 'guido', 'irv']
>>> sorted(tel)
['guido', 'irv', 'jack']
>>> 'guido' in tel
True
>>> 'jack' not in tel
False
```

### 辞書の構築

**`dict()` コンストラクター:**
キー値ペアのシーケンスから直接構築:

```python
>>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
{'sape': 4139, 'guido': 4127, 'jack': 4098}
```

**辞書内包表記:**
任意のキーと値の式から辞書を作成:

```python
>>> {x: x**2 for x in (2, 4, 6)}
{2: 4, 4: 16, 6: 36}
```

**キーワード引数:**
キーが単純な文字列の場合、ペアをキーワード引数で指定する方が簡単なこともある:

```python
>>> dict(sape=4139, guido=4127, jack=4098)
{'sape': 4139, 'guido': 4127, 'jack': 4098}
```

## 5.6. ループのテクニック

### 辞書のループ

**`items()` メソッド:**
キーと対応する値を同時に取得:

```python
>>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}
>>> for k, v in knights.items():
...     print(k, v)
...
gallahad the pure
robin the brave
```

### シーケンスのループ

**`enumerate()` 関数:**
位置インデックスと対応する値を同時に取得:

```python
>>> for i, v in enumerate(['tic', 'tac', 'toe']):
...     print(i, v)
...
0 tic
1 tac
2 toe
```

### 複数シーケンスの同時ループ

**`zip()` 関数:**
2つ以上のシーケンスを同時にループ:

```python
>>> questions = ['name', 'quest', 'favorite color']
>>> answers = ['lancelot', 'the holy grail', 'blue']
>>> for q, a in zip(questions, answers):
...     print('What is your {0}?  It is {1}.'.format(q, a))
...
What is your name?  It is lancelot.
What is your quest?  It is the holy grail.
What is your favorite color?  It is blue.
```

### 逆順ループ

**`reversed()` 関数:**
シーケンスを逆順にループ:

```python
>>> for i in reversed(range(1, 10, 2)):
...     print(i)
...
9
7
5
3
1
```

### ソート順ループ

**`sorted()` 関数:**
ソートされた順序でループ:
- 新しいソート済みリストを返す
- ソース(元のデータ)は変更しない

```python
>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
>>> for i in sorted(basket):
...     print(i)
...
apple
apple
banana
orange
orange
pear
```

### 重複を除いてソート順ループ

**`set()` と `sorted()` の組み合わせ:**
シーケンスのユニークな要素をソート順でループする慣用的な方法:

```python
>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
>>> for f in sorted(set(basket)):
...     print(f)
...
apple
banana
orange
pear
```

### ループ中のリスト変更

**注意:**
ループしてる最中にリストを変更したくなることがある。

**でも、新しいリストを作る方が簡単で安全なことが多い:**

```python
>>> import math
>>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]
>>> filtered_data = []
>>> for value in raw_data:
...     if not math.isnan(value):
...         filtered_data.append(value)
...
>>> filtered_data
[56.2, 51.7, 55.3, 52.5, 47.8]
```

## 5.7. 条件についてもっと

**`while` と `if` 文で使われる条件:**
- 比較だけじゃなく、任意の演算子を含められる

### 演算子の種類

**比較演算子 `in` と `not in`:**
- 値がシーケンス内にあるか(ないか)をチェック

**比較演算子 `is` と `is not`:**
- 2つのオブジェクトが本当に同じオブジェクトかを比較

**すべての比較演算子の優先度:**
- 同じ
- すべての数値演算子より低い

### 比較の連鎖

**比較は連鎖できる:**

```python
a < b == c
```

これは `a` が `b` より小さく、さらに `b` が `c` と等しいかをテスト。

### ブール演算子

**`and` と `or` で組み合わせ:**
- 比較の結果(または他のブール式)を組み合わせられる

**`not` で否定:**
- 比較の結果を否定できる

**優先度:**
- これらは比較演算子より低い優先度
- その中では:
  - `not` が最も優先度が高い
  - `or` が最も優先度が低い
- つまり `A and not B or C` は `(A and (not B)) or C` と同等
- いつも通り、括弧で望ましい構成を表現できる

### 短絡演算子

**`and` と `or` は「短絡」演算子:**
- 引数は左から右へ評価される
- 結果が決まり次第、評価が停止する

**例:**
- `A` と `C` が真で `B` が偽の場合
- `A and B and C` は式 `C` を評価しない

**ブールとしてじゃなく一般的な値として使う場合:**
- 短絡演算子の戻り値は、最後に評価された引数

### 比較結果の変数への代入

**比較や他のブール式の結果を変数に代入できる:**

```python
>>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'
>>> non_null = string1 or string2 or string3
>>> non_null
'Trondheim'
```

### セイウチ演算子

**Pythonでは、Cと違って:**
- 式内での代入は、**セイウチ演算子 `:=`** で明示的に行う必要がある
- これによりCプログラムでよくある問題を回避:
  - `==` を意図してたのに式で `=` と打っちゃう問題

## 5.8. シーケンスと他の型の比較

**シーケンスオブジェクト:**
- 通常、同じシーケンス型の他のオブジェクトと比較できる

**比較方法: 辞書式順序(lexicographical ordering)**

1. 最初の2つの項目を比較
2. 異なれば、これが比較の結果を決定
3. 等しければ、次の2つの項目を比較
4. これをどちらかのシーケンスが尽きるまで続ける
5. 比較する2つの項目が両方とも同じ型のシーケンスなら、辞書式比較を再帰的に実行
6. 2つのシーケンスのすべての項目が等しいなら、シーケンスは等しいとみなされる
7. 一方のシーケンスがもう一方の最初の部分列なら、短い方が小さい(より小)

**文字列の辞書式順序:**
- 個別の文字を並べるのにUnicodeコードポイント番号を使う

### 比較の例

同じ型のシーケンス間の比較の例:

```python
(1, 2, 3)              < (1, 2, 4)
[1, 2, 3]              < [1, 2, 4]
'ABC' < 'C' < 'Pascal' < 'Python'
(1, 2, 3, 4)           < (1, 2, 4)
(1, 2)                 < (1, 2, -1)
(1, 2, 3)              == (1.0, 2.0, 3.0)
(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)
```

### 異なる型の比較

**`<` または `>` での異なる型の比較:**
- オブジェクトが適切な比較メソッドを持ってれば合法

**例:**
- 混合数値型は数値で比較される
- だから `0` は `0.0` と等しい

**それ以外:**
- 任意の順序を提供するんじゃなく
- インタープリタは `TypeError` 例外を発生させる

---

## この章の重要ポイントまとめ( ˶'ᵕ'˶)

### リストメソッド
- `append()`, `extend()`, `insert()`, `remove()`, `pop()`, `clear()`
- `index()`, `count()`, `sort()`, `reverse()`, `copy()`
- スタック(LIFO): `append()` と `pop()` で実現
- キュー(FIFO): `collections.deque` を使う

### リスト内包表記
- `[式 for 項目 in iterable if 条件]`
- 簡潔で読みやすい!
- ネストも可能

### その他のデータ構造
- **タプル**: イミュータブル、異種要素、括弧で囲む
- **セット**: 重複なし、順序なし、中括弧 `{}` または `set()`
- **辞書**: キー:値ペア、中括弧 `{}`

### ループテクニック
- `items()`: 辞書のキーと値
- `enumerate()`: インデックスと値
- `zip()`: 複数シーケンスを同時に
- `reversed()`: 逆順
- `sorted()`: ソート順

### 条件と比較
- 比較の連鎖が可能
- `and`, `or`, `not` のブール演算子
- 短絡評価
- 辞書式順序での比較

次は6章いくよ〜!URL貼って!( ˶>ᴗ<˶)
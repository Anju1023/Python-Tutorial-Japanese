<!-- claude_translate/tutorial_009.md -->

# 9. クラス (Classes)

## クラスって何?

クラスは、**データ(情報)と機能(動作)をひとまとめにする仕組み**だよ!

新しいクラスを作ると、新しい「型」のオブジェクトができるの。そして、その型の「インスタンス(実体)」をいくつも作れるんだ。

- **インスタンス**には「属性(attribute)」をつけて、状態を保存できる
- **インスタンス**には「メソッド(method)」があって、状態を変更できる

### 他の言語との違い

Pythonのクラスの仕組みは、C++やModula-3のクラス機能をミックスしたようなものだよ。

**Pythonクラスの特徴:**
- 最小限の新しい構文とルールでクラスを追加
- オブジェクト指向プログラミングの標準機能を全て提供
  - **継承(inheritance)**: 複数の親クラスを持てる
  - **オーバーライド(override)**: 子クラスが親クラスのメソッドを上書きできる
  - **メソッドから親クラスのメソッドを呼べる**
- オブジェクトにはどんな種類のデータでも、どんな量でも入れられる
- モジュールと同じく、クラスも動的(プログラム実行中に作られて、後から変更できる)

**C++との違い:**
- クラスメンバー(データメンバー含む)は通常「public(公開)」
- メンバー関数は全て「virtual(仮想関数)」
- メソッド内でオブジェクトのメンバーを参照するショートカットがない
  - メソッド関数は、オブジェクトを表す第1引数を明示的に宣言する必要がある
  - これは呼び出し時に暗黙的に渡される
- クラス自体もオブジェクト(だからインポートやリネームができる!)
- 組み込み型も親クラスとして使える
- 組み込み演算子(算術演算子、添字アクセスなど)のほとんどを、クラスインスタンス用に再定義できる

---

## 9.1. 名前とオブジェクトについて

オブジェクトには**個性(identity)**があって、複数の名前(複数のスコープで)が同じオブジェクトにバインド(結び付けられる)できるよ。これを他の言語では**エイリアシング(aliasing)**って呼ぶんだ。

最初Pythonを見たときは、これってあんまり意識しないかもしれないし、イミュータブル(変更不可能)な基本型(数値、文字列、タプル)を扱うときは無視しても大丈夫。

**でも!** リスト、辞書、その他ほとんどの型みたいな**ミュータブル(変更可能)なオブジェクト**を扱うときは、エイリアシングが予想外の影響を与えることがあるから注意!

通常これはプログラムの役に立つことが多いよ。なぜなら、エイリアスはポインタみたいに振る舞うから:

**例えば:**
- オブジェクトを渡すのは安い(ポインタだけ渡すから)
- 関数が引数として渡されたオブジェクトを変更したら、呼び出し側もその変更が見える
  - これでPascalみたいに2種類の引数渡しメカニズムが必要なくなる!

---

## 9.2. Pythonのスコープと名前空間

クラスを紹介する前に、Pythonのスコープルールについて話さないといけないの。クラス定義は名前空間でちょっとトリッキーなことをするから、スコープと名前空間がどう動くか理解しないと、何が起こってるか完全には理解できないんだ。

ちなみに、この知識は上級Pythonプログラマーにとって役立つよ!

### 定義から始めよう

**名前空間(namespace)**は、名前からオブジェクトへのマッピングだよ。

現在、ほとんどの名前空間はPythonの辞書として実装されてるんだけど、普通はそれに気づかない(パフォーマンス以外では)。将来変わるかもしれないしね。

**名前空間の例:**
- **組み込み名のセット** - `abs()`などの関数や、組み込み例外名
- **モジュール内のグローバル名**
- **関数呼び出し時のローカル名**
- **オブジェクトの属性のセット**(ある意味、これも名前空間を形成する)

**名前空間について知っておくべき重要なこと:**
**異なる名前空間の名前同士には、全く関係がない!**

例えば、2つの異なるモジュールが両方とも`maximize`という関数を定義しても混乱しない。モジュールのユーザーは、モジュール名を前につけて区別するから。

> ちなみに、ドット(`.`)の後の名前は全部「属性(attribute)」って呼ぶよ。
> 
> 例: `z.real`という式では、`real`はオブジェクト`z`の属性
> 
> 厳密に言うと、モジュール内の名前への参照も属性参照だよ:
> `modname.funcname`という式では、`modname`がモジュールオブジェクトで、`funcname`がその属性。
> この場合、モジュールの属性とモジュール内で定義されたグローバル名の間には、直接的なマッピングがある(同じ名前空間を共有してる!)

**属性には2種類ある:**
- **読み取り専用(read-only)**
- **書き込み可能(writable)** 
  - 書き込み可能な場合、代入ができる。例: `modname.the_answer = 42`
  - `del`文で削除もできる。例: `del modname.the_answer`は、`modname`という名前のオブジェクトから`the_answer`属性を削除する

### 名前空間のライフサイクル

名前空間は**異なるタイミングで作られて、異なる寿命**を持つよ:

1. **組み込み名の名前空間**
   - Pythonインタープリタ起動時に作成
   - 削除されることはない

2. **モジュールのグローバル名前空間**
   - モジュール定義が読み込まれた時に作成
   - 通常、インタープリタが終了するまで続く
   - トップレベルのインタープリタ実行文(スクリプトファイルから読むか対話的に実行)は、`__main__`というモジュールの一部とみなされるから、独自のグローバル名前空間を持つ
   - (組み込み名も実は`builtins`というモジュール内に存在してる)

3. **関数のローカル名前空間**
   - 関数が呼び出された時に作成
   - 関数がreturnするか、関数内で処理されない例外が発生した時に削除
   - (実際には「忘れられる」と言った方が正確かも)
   - 再帰呼び出しは、それぞれが独自のローカル名前空間を持つ

### スコープとは?

**スコープ(scope)**は、Pythonプログラムのテキスト上の領域で、**名前空間に直接アクセスできる場所**のことだよ。

「直接アクセス」っていうのは、名前への修飾なし(ドットなし)の参照が、その名前空間内でその名前を探そうとするってこと。

スコープは静的に決定されるけど、動的に使われる。実行中のどの時点でも、**直接アクセス可能な名前空間を持つ、3つまたは4つのネストされたスコープ**があるよ:

1. **最も内側のスコープ**(最初に探される) - ローカル名を含む
2. **外側の関数のスコープ**(最も近い外側のスコープから探していく) - 非ローカル、かつ非グローバルな名前を含む
3. **次から最後のスコープ** - 現在のモジュールのグローバル名を含む
4. **最も外側のスコープ**(最後に探される) - 組み込み名を含む名前空間

### global と nonlocal

**`global`宣言:**
- 名前が`global`と宣言されると、全ての参照と代入は、モジュールのグローバル名を含む中間スコープに直接行く

**`nonlocal`宣言:**
- 最も内側のスコープの外で見つかった変数を再バインドするには、`nonlocal`文が使える
- `nonlocal`と宣言されてない場合、それらの変数は読み取り専用
  - (そういう変数に書き込もうとすると、最も内側のスコープに新しいローカル変数が作られて、同名の外側の変数は変更されない)

### 重要なポイント

通常、ローカルスコープは(テキスト的に)現在の関数のローカル名を参照する。

**関数の外では:**
- ローカルスコープはグローバルスコープと同じ名前空間(モジュールの名前空間)を参照

**クラス定義は:**
- ローカルスコープに別の名前空間を置く

**スコープはテキスト的に決定される**ことを理解するのが大事:
- モジュールで定義された関数のグローバルスコープは、そのモジュールの名前空間
- どこから、どんなエイリアスで関数が呼ばれても変わらない

一方、**名前の実際の検索は動的**に、実行時に行われる。でも、言語定義は「コンパイル」時の静的な名前解決に向かって進化してるから、動的な名前解決に頼らないで! (実際、ローカル変数はすでに静的に決定されてる)

### Python特有の癖

`global`や`nonlocal`文が有効でない場合、**名前への代入は常に最も内側のスコープに行く**。

**代入はデータをコピーしない** - 名前をオブジェクトにバインド(結びつける)だけ。

削除も同じ: `del x`は、ローカルスコープが参照する名前空間から`x`のバインディングを削除する。

実際、**新しい名前を導入する全ての操作はローカルスコープを使う**:
- 特に、`import`文や関数定義は、モジュールや関数名をローカルスコープにバインドする

`global`文は、特定の変数がグローバルスコープにあって、そこで再バインドされるべきだと示すために使える。

`nonlocal`文は、特定の変数が外側のスコープにあって、そこで再バインドされるべきだと示す。

---

## 9.2.1. スコープと名前空間の例

これは、異なるスコープと名前空間を参照する方法、`global`と`nonlocal`が変数バインディングにどう影響するかを示す例だよ:

```python
def scope_test():
    def do_local():
        spam = "local spam"
    
    def do_nonlocal():
        nonlocal spam
        spam = "nonlocal spam"
    
    def do_global():
        global spam
        spam = "global spam"
    
    spam = "test spam"
    do_local()
    print("After local assignment:", spam)
    do_nonlocal()
    print("After nonlocal assignment:", spam)
    do_global()
    print("After global assignment:", spam)

scope_test()
print("In global scope:", spam)
```

**このコードの出力:**

```
After local assignment: test spam
After nonlocal assignment: nonlocal spam
After global assignment: nonlocal spam
In global scope: global spam
```

**何が起こってるか:**

- **ローカル代入**(デフォルト) - `scope_test`の`spam`バインディングを変更しなかった
- **nonlocal代入** - `scope_test`の`spam`バインディングを変更した
- **global代入** - モジュールレベルのバインディングを変更した

`global`代入の前には、`spam`の既存のバインディングがなかったことにも注目してね。

---

## 9.3. クラスの基本

クラスは、少しの新しい構文、3つの新しいオブジェクト型、いくつかの新しいセマンティクス(意味)を導入するよ。

### 9.3.1. クラス定義の構文

最もシンプルなクラス定義は次のような感じ:

```python
class ClassName:
    <statement-1>
    .
    .
    .
    <statement-N>
```

**重要:**
- クラス定義も、関数定義(`def`文)と同じく、**実行される前は効果がない**
- (理論的には、`if`文の分岐の中や、関数の中にクラス定義を置くこともできる)

実際には、クラス定義内の文は通常は関数定義になるけど、他の文も許されてるし、時々役立つよ。これは後で説明するね。

クラス内の関数定義は、通常、特殊な形式の引数リストを持つ。これはメソッドの呼び出し規約によって決められてる。これも後で説明するよ。

**クラス定義に入ると:**
- 新しい名前空間が作られ、ローカルスコープとして使われる
- つまり、ローカル変数への全ての代入はこの新しい名前空間に入る
- 特に、関数定義はここに新しい関数の名前をバインドする

**クラス定義から通常の方法で抜けると(終わりまで行くと):**
- **クラスオブジェクト**が作られる
- これは基本的に、クラス定義で作られた名前空間の内容のラッパー(包み)
- クラスオブジェクトについては次のセクションで詳しく学ぶよ
- 元のローカルスコープ(クラス定義に入る直前のもの)が復元される
- クラスオブジェクトは、クラス定義ヘッダーで与えられたクラス名(例では`ClassName`)にバインドされる

### 9.3.2. クラスオブジェクト

クラスオブジェクトは**2種類の操作**をサポートするよ:
1. **属性参照**
2. **インスタンス化**

#### 属性参照

**属性参照**は、Pythonの全ての属性参照で使われる標準構文を使う: `obj.name`

有効な属性名は、クラスオブジェクトが作られたときにクラスの名前空間にあった全ての名前だよ。

例えば、クラス定義がこうだったら:

```python
class MyClass:
    """A simple example class"""
    i = 12345
    
    def f(self):
        return 'hello world'
```

`MyClass.i`と`MyClass.f`は有効な属性参照で、それぞれ整数と関数オブジェクトを返す。

クラス属性には代入もできるから、`MyClass.i`の値を代入で変更できるよ。

`__doc__`も有効な属性で、クラスに属するdocstringを返す: `"A simple example class"`

#### インスタンス化

**クラスのインスタンス化**は関数記法を使う。クラスオブジェクトを、クラスの新しいインスタンスを返すパラメータなしの関数だと思えばいいんだ。

例えば(上のクラスを仮定):

```python
x = MyClass()
```

これでクラスの新しいインスタンスが作られ、このオブジェクトがローカル変数`x`に代入される。

**インスタンス化操作**(クラスオブジェクトを「呼ぶ」)は空のオブジェクトを作る。

多くのクラスは、特定の初期状態にカスタマイズされたインスタンスを作りたいよね。だからクラスは`__init__()`という特別なメソッドを定義できる:

```python
def __init__(self):
    self.data = []
```

クラスが`__init__()`メソッドを定義すると、クラスのインスタンス化は、新しく作られたクラスインスタンスに対して自動的に`__init__()`を呼び出す。

だから、この例では、新しい初期化されたインスタンスは次のように取得できる:

```python
x = MyClass()
```

もちろん、`__init__()`メソッドはより柔軟性のために引数を持てる。その場合、クラスインスタンス化演算子に与えられた引数は`__init__()`に渡される。例えば:

```python
>>> class Complex:
...     def __init__(self, realpart, imagpart):
...         self.r = realpart
...         self.i = imagpart
...
>>> x = Complex(3.0, -4.5)
>>> x.r, x.i
(3.0, -4.5)
```

### 9.3.3. インスタンスオブジェクト

さて、インスタンスオブジェクトで何ができる? インスタンスオブジェクトが理解できる唯一の操作は**属性参照**だよ。

有効な属性名には2種類ある:
1. **データ属性**
2. **メソッド**

#### データ属性

**データ属性**は、Smalltalkの「インスタンス変数」や、C++の「データメンバー」に相当するよ。

データ属性は宣言する必要がない! ローカル変数みたいに、最初に代入されたときに存在するようになるの。

例えば、`x`が上で作った`MyClass`のインスタンスなら、次のコードは値`16`を出力して、何も痕跡を残さない:

```python
x.counter = 1
while x.counter < 10:
    x.counter = x.counter * 2
print(x.counter)
del x.counter
```

#### メソッド

もう1つのインスタンス属性参照は**メソッド**。

メソッドは、オブジェクトに「属する」関数だよ。(Pythonでは、「メソッド」という用語はクラスインスタンス独自のものではない: 他のオブジェクト型もメソッドを持てる。例えば、リストオブジェクトにはappend、insert、remove、sortなどのメソッドがある。ただし、以降の説明では、特に明記しない限り、「メソッド」という用語はクラスインスタンスオブジェクトのメソッドだけを意味するよ)

インスタンスオブジェクトの有効なメソッド名は、そのクラスに依存する。定義上、関数オブジェクトであるクラスの全ての属性は、そのインスタンスの対応するメソッドを定義する。

だから例では、`x.f`は有効なメソッド参照(`MyClass.f`が関数だから)。でも`x.i`は違う(`MyClass.i`が関数じゃないから)。

でも`x.f`は`MyClass.f`と同じものじゃないよ - それは**メソッドオブジェクト**であって、関数オブジェクトじゃない。

### 9.3.4. メソッドオブジェクト

通常、メソッドはバインドされた直後に呼ばれる:

```python
x.f()
```

`MyClass`の例では、これは文字列`'hello world'`を返す。

でも、メソッドをすぐに呼ぶ必要はないよ: `x.f`はメソッドオブジェクトで、保存しておいて後で呼び出せる。例えば:

```python
xf = x.f
while True:
    print(xf())
```

これは時間の終わりまで`hello world`を出力し続けるよ。

**メソッドが呼ばれると正確に何が起こるの?**

`x.f()`が引数なしで呼ばれたのに気づいたかな? `f()`の関数定義は引数を指定してたのに。引数に何が起こったの? 確実にPythonは、引数が必要な関数を引数なしで呼んだら例外を発生させるはず... たとえその引数が実際には使われてなくても...

実は、答えは推測できたかも: **メソッドの特別なところは、インスタンスオブジェクトが関数の第1引数として渡される**こと。

例では、呼び出し`x.f()`は`MyClass.f(x)`と完全に等価なんだ。

一般的に、n個の引数のリストでメソッドを呼ぶことは、メソッドのインスタンスオブジェクトを第1引数の前に挿入して作られた引数リストで、対応する関数を呼ぶことと等価だよ。

**どうやって動くの?**

メソッドがどう動くか理解できなかったら、実装を見ると明確になるかも。

インスタンスの非データ属性が参照されると、インスタンスのクラスが探される。名前が有効なクラス属性で、それが関数オブジェクトの場合、(ポインタを)インスタンスオブジェクトと、ちょうど見つけた関数オブジェクトを抽象オブジェクトにパックすることで、メソッドオブジェクトが作られる: これがメソッドオブジェクト。

メソッドオブジェクトが引数リストで呼ばれると、インスタンスオブジェクトと引数リストから新しい引数リストが構築されて、関数オブジェクトがこの新しい引数リストで呼ばれるんだ。

### 9.3.5. クラス変数とインスタンス変数

一般的に:
- **インスタンス変数** - 各インスタンスに固有のデータ用
- **クラス変数** - クラスの全インスタンスで共有される属性とメソッド用

例:

```python
class Dog:
    kind = 'canine'        # 全インスタンスで共有されるクラス変数
    
    def __init__(self, name):
        self.name = name   # 各インスタンスに固有のインスタンス変数

>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>> d.kind                 # 全ての犬で共有
'canine'
>>> e.kind                 # 全ての犬で共有
'canine'
>>> d.name                 # dに固有
'Fido'
>>> e.name                 # eに固有
'Buddy'
```

**注意!** リストや辞書のような**ミュータブル(変更可能)なオブジェクト**を含む共有データは、予想外の効果を持つことがある。

例えば、次のコードの`tricks`リストは、クラス変数として使うべきじゃない。なぜなら、たった1つのリストが全ての`Dog`インスタンスで共有されちゃうから:

```python
class Dog:
    tricks = []             # クラス変数の誤った使い方
    
    def __init__(self, name):
        self.name = name
    
    def add_trick(self, trick):
        self.tricks.append(trick)

>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>> d.add_trick('roll over')
>>> e.add_trick('play dead')
>>> d.tricks                # 予想外に全ての犬で共有されてる
['roll over', 'play dead']
```

**正しいクラス設計**では、代わりにインスタンス変数を使うべき:

```python
class Dog:
    def __init__(self, name):
        self.name = name
        self.tricks = []    # 各犬用の新しい空のリストを作る
    
    def add_trick(self, trick):
        self.tricks.append(trick)

>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>> d.add_trick('roll over')
>>> e.add_trick('play dead')
>>> d.tricks
['roll over']
>>> e.tricks
['play dead']
```

---

## 9.4. ランダムな注意点

同じ属性名がインスタンスとクラスの両方にある場合、**属性検索はインスタンスを優先**するよ:

```python
>>> class Warehouse:
        purpose = 'storage'
        region = 'west'

>>> w1 = Warehouse()
>>> print(w1.purpose, w1.region)
storage west
>>> w2 = Warehouse()
>>> w2.region = 'east'
>>> print(w2.purpose, w2.region)
storage east
```

データ属性は、メソッドからも、オブジェクトの通常のユーザー(「クライアント」)からも参照できる。言い換えると、**クラスは純粋な抽象データ型を実装するのには使えない**。実際、Pythonにはデータ隠蔽を強制するものは何もない - 全て慣習に基づいてる。(一方、Cで書かれたPython実装は、実装の詳細を完全に隠して、オブジェクトへのアクセスを制御できる。これはCで書かれたPythonの拡張で使える)

クライアントはデータ属性を注意して使うべき - クライアントは、自分のデータ属性を踏みつけることで、メソッドによって維持される不変条件を台無しにしちゃう可能性があるよ。

ただし、クライアントは名前の衝突を避ける限り、メソッドの有効性に影響を与えずに、インスタンスオブジェクトに独自のデータ属性を追加できる。ここでも、命名規則が多くの頭痛を防げるよ。

メソッドの中から、データ属性(や他のメソッド!)を参照するショートカットはない。私はこれがメソッドの可読性を実際に高めてると思うよ: メソッドをざっと見たときに、ローカル変数とインスタンス変数を混同する可能性がないからね。

よく、**メソッドの第1引数は`self`と呼ばれる**。これは単なる慣習にすぎない: `self`という名前はPythonには全く特別な意味はないんだ。

ただし、この慣習に従わないと、他のPythonプログラマーにとってコードが読みにくくなるかもしれないし、クラスブラウザプログラムがこういう慣習に依存して書かれてる可能性もあるよ。

クラス属性である任意の関数オブジェクトは、そのクラスのインスタンスのメソッドを定義する。関数定義がテキスト的にクラス定義の中に入ってる必要はない: 関数オブジェクトをクラスのローカル変数に代入するのもOK。例えば:

```python
# クラスの外で定義された関数
def f1(self, x, y):
    return min(x, x+y)

class C:
    f = f1
    
    def g(self):
        return 'hello world'
    
    h = g
```

今、`f`、`g`、`h`は全て、関数オブジェクトを参照するクラス`C`の属性で、結果的に`C`のインスタンスの全てのメソッドになる。`h`は`g`と完全に等価。

ただし、この慣習は通常プログラムの読者を混乱させるだけだから注意してね。

メソッドは、`self`引数のメソッド属性を使って他のメソッドを呼べる:

```python
class Bag:
    def __init__(self):
        self.data = []
    
    def add(self, x):
        self.data.append(x)
    
    def addtwice(self, x):
        self.add(x)
        self.add(x)
```

メソッドは、通常の関数と同じ方法でグローバル名を参照できる。メソッドに関連付けられたグローバルスコープは、その定義を含むモジュールだよ。(クラスはグローバルスコープとして使われることはない)

グローバルスコープを使う正当な理由はたくさんある: まず、グローバルスコープにインポートされた関数やモジュールは、メソッドから使えるし、その中で定義された関数やクラスも使える。通常、メソッドを含むクラス自体がこのグローバルスコープで定義されてる。次のセクションで、メソッドが自分のクラスを参照したい正当な理由をいくつか見つけるよ。

各値はオブジェクトで、したがって**クラス(型とも呼ばれる)**を持つ。それは`object.__class__`として保存されてる。

---

## 9.5. 継承 (Inheritance)

もちろん、継承をサポートしてなかったら、「クラス」という名前に値しない言語機能になっちゃうよね。派生クラス定義の構文はこんな感じ:

```python
class DerivedClassName(BaseClassName):
    <statement-1>
    .
    .
    .
    <statement-N>
```

名前`BaseClassName`は、派生クラス定義を含むスコープで定義されてる必要がある。

基底クラス名の代わりに、他の任意の式も許されてる。これは、基底クラスが別のモジュールで定義されてるときなんかに便利:

```python
class DerivedClassName(modname.BaseClassName):
```

**派生クラス定義の実行**は基底クラスと同じように進む。クラスオブジェクトが構築されるとき、基底クラスが記憶される。これは属性参照を解決するのに使われる: 要求された属性がクラスで見つからなかった場合、検索は基底クラスを見に行く。基底クラス自体が他のクラスから派生してる場合、このルールは再帰的に適用される。

派生クラスのインスタンス化に特別なことはない: `DerivedClassName()`は、クラスの新しいインスタンスを作る。

**メソッド参照は次のように解決される:**
- 対応するクラス属性が検索される
- 必要に応じて基底クラスのチェーンを下って検索
- これが関数オブジェクトを生成すれば、メソッド参照は有効

**派生クラスは基底クラスのメソッドをオーバーライド(上書き)できる。**

メソッドは、同じオブジェクトの他のメソッドを呼ぶときに特別な特権を持たないから、基底クラスのメソッドが同じ基底クラスで定義された別のメソッドを呼ぶと、それをオーバーライドする派生クラスのメソッドを呼び出すことになるかもしれない。(C++プログラマー向け: **Pythonの全てのメソッドは事実上`virtual`**)

派生クラスのオーバーライドメソッドは、実際には単に同じ名前の基底クラスメソッドを置き換えるのではなく、拡張したいかもしれない。基底クラスメソッドを直接呼ぶ簡単な方法がある: `BaseClassName.methodname(self, arguments)`を呼ぶだけ。

これはクライアントにとっても時々役立つよ。(これは、基底クラスがグローバルスコープで`BaseClassName`としてアクセス可能な場合にのみ機能することに注意)

Pythonには継承で動く2つの組み込み関数がある:

- **`isinstance()`** - インスタンスの型をチェック:
  - `isinstance(obj, int)`は、`obj.__class__`が`int`か、`int`から派生したクラスの場合のみ`True`

- **`issubclass()`** - クラスの継承をチェック:
  - `issubclass(bool, int)`は`True`(`bool`は`int`のサブクラス)
  - でも`issubclass(float, int)`は`False`(`float`は`int`のサブクラスじゃない)

### 9.5.1. 多重継承 (Multiple Inheritance)

Pythonは多重継承の形式もサポートしてる。複数の基底クラスを持つクラス定義はこんな感じ:

```python
class DerivedClassName(Base1, Base2, Base3):
    <statement-1>
    .
    .
    .
    <statement-N>
```

ほとんどの目的で、最も単純なケースでは、親クラスから継承された属性の検索を**深さ優先、左から右**、階層にオーバーラップがある場合は同じクラスで2回検索しない、と考えられる。

つまり、属性が`DerivedClassName`で見つからない場合、`Base1`で検索され、次に(再帰的に)`Base1`の基底クラスで検索され、そこで見つからなかったら`Base2`で検索され、という感じ。

実際には、それよりもう少し複雑: **メソッド解決順序(MRO)は動的に変化**して、`super()`への協調的な呼び出しをサポートする。このアプローチは、他の多重継承言語では「call-next-method」として知られていて、単一継承言語で見られるsuper呼び出しよりも強力なんだ。

**動的な順序付けが必要な理由:**
- 全ての多重継承のケースは、1つ以上の**ダイヤモンド関係**(最下位のクラスから複数のパスを通じて少なくとも1つの親クラスにアクセスできる)を示すから
- 例えば、全てのクラスは`object`から継承するから、多重継承のケースは全て`object`に到達する複数のパスを提供する

基底クラスが複数回アクセスされないようにするため、動的アルゴリズムは、各クラスで指定された左から右の順序を保ち、各親を1回だけ呼び出し、単調(クラスをサブクラス化してもその親の優先順序に影響しない)な方法で検索順序を線形化する。

これらの特性を合わせることで、多重継承で信頼性があり拡張可能なクラスを設計できるようになるんだ。詳細は: https://www.python.org/download/releases/2.3/mro/

---

## 9.6. プライベート変数

オブジェクトの内部からしかアクセスできない「プライベート」なインスタンス変数は、Pythonには存在しない。

でも、ほとんどのPythonコードが従う**慣習**がある: アンダースコアで始まる名前(例: `_spam`)は、APIの非公開部分として扱うべき(それが関数、メソッド、データメンバーであっても)。実装の詳細とみなして、予告なく変更される可能性があるよ。

### 名前マングリング (Name Mangling)

クラスプライベートなメンバーの正当な使用ケース(つまり、サブクラスで定義された名前との名前衝突を避ける)があるから、そういう仕組みへの限定的なサポートがある。これを**名前マングリング**と呼ぶ。

`__spam`という形式の識別子(最低2つの先頭アンダースコア、最大1つの末尾アンダースコア)は、テキスト的に`_classname__spam`に置き換えられる。ここで`classname`は、先頭のアンダースコアを取り除いた現在のクラス名。

このマングリングは、クラスの定義内で発生する限り、識別子の構文的な位置に関係なく行われる。

**名前マングリングが役立つ理由:**
- サブクラスがメソッドをオーバーライドしても、クラス内メソッド呼び出しを壊さないようにできる

例:

```python
class Mapping:
    def __init__(self, iterable):
        self.items_list = []
        self.__update(iterable)
    
    def update(self, iterable):
        for item in iterable:
            self.items_list.append(item)
    
    __update = update  # 元のupdate()メソッドのプライベートコピー

class MappingSubclass(Mapping):
    def update(self, keys, values):
        # update()の新しいシグネチャを提供
        # でも__init__()は壊さない
        for item in zip(keys, values):
            self.items_list.append(item)
```

上の例は、`MappingSubclass`が`__update`識別子を導入しても動く。なぜなら、`Mapping`クラスでは`_Mapping__update`に置き換えられ、`MappingSubclass`クラスでは`_MappingSubclass__update`に置き換えられるから。

**注意:**
- マングリングルールは主に事故を避けるために設計されてる
- プライベートとみなされる変数にアクセスしたり変更したりすることは依然として可能
- デバッガなど特別な状況では役立つこともある
- `exec()`や`eval()`に渡されたコードは、呼び出し元クラスのクラス名を現在のクラスとみなさない(これは`global`文の効果に似てる)
- 同じ制限が`getattr()`、`setattr()`、`delattr()`、`__dict__`を直接参照するときにも適用される

---

## 9.7. その他いろいろ

Pascalの「レコード」やCの「構造体」に似たデータ型があると便利な時がある。いくつかの名前付きデータ項目をまとめるやつ。空のクラス定義がうまくいくよ:

```python
class Employee:
    pass

john = Employee()  # 空の従業員レコードを作成

# レコードのフィールドを埋める
john.name = 'John Doe'
john.dept = 'computer lab'
john.salary = 1000
```

特定の抽象データ型を期待するPythonコードの断片には、代わりにそのデータ型のメソッドをエミュレートするクラスを渡せることが多い。

例えば、ファイルオブジェクトからデータをフォーマットする関数がある場合、代わりに文字列バッファからデータを取得する`read()`と`readline()`メソッドを持つクラスを定義して、引数として渡せる。

**インスタンスメソッドオブジェクトにも属性がある:**
- `m.__self__` - メソッド`m()`を持つインスタンスオブジェクト
- `m.__func__` - メソッドに対応する関数オブジェクト

---

## 9.8. イテレータ (Iterators)

今頃、ほとんどのコンテナオブジェクトが`for`文を使ってループできることに気づいてるはず:

```python
for element in [1, 2, 3]:
    print(element)
for element in (1, 2, 3):
    print(element)
for key in {'one':1, 'two':2}:
    print(key)
for char in "123":
    print(char)
for line in open("myfile.txt"):
    print(line, end='')
```

このアクセススタイルは、明確で、簡潔で、便利。イテレータの使用はPythonに浸透して統一してるんだ。

**裏側では:**
1. `for`文は、コンテナオブジェクトに対して`iter()`を呼ぶ
2. この関数は、`__next__()`メソッドを定義するイテレータオブジェクトを返す
3. `__next__()`は、コンテナ内の要素に一度に1つアクセスする
4. 要素がなくなると、`__next__()`は`StopIteration`例外を発生させる
5. これが`for`ループに終了を伝える
6. `__next__()`メソッドは、`next()`組み込み関数を使って呼べる

このような動作の例:

```python
>>> s = 'abc'
>>> it = iter(s)
>>> it
<str_iterator object at 0x10c90e650>
>>> next(it)
'a'
>>> next(it)
'b'
>>> next(it)
'c'
>>> next(it)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
    next(it)
StopIteration
```

### 自分のクラスにイテレータの振る舞いを追加する

イテレータプロトコルの仕組みを見たから、クラスにイテレータの振る舞いを追加するのは簡単だよ。

**やり方:**
1. `__next__()`メソッドを持つオブジェクトを返す`__iter__()`メソッドを定義
2. クラスが`__next__()`を定義してるなら、`__iter__()`は`self`を返すだけでいい

例:

```python
class Reverse:
    """シーケンスを逆方向にループするイテレータ"""
    def __init__(self, data):
        self.data = data
        self.index = len(data)
    
    def __iter__(self):
        return self
    
    def __next__(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.data[self.index]

>>> rev = Reverse('spam')
>>> iter(rev)
<__main__.Reverse object at 0x00A1DB50>
>>> for char in rev:
...     print(char)
...
m
a
p
s
```

---

## 9.9. ジェネレータ (Generators)

**ジェネレータ**は、イテレータを作るためのシンプルで強力なツールだよ。

通常の関数のように書くけど、データを返したいときに`yield`文を使う。`next()`が呼ばれるたびに、ジェネレータは中断したところから再開する(全てのデータ値と最後に実行された文を覚えてる)。

例を見れば、ジェネレータを作るのがとても簡単だってわかるよ:

```python
def reverse(data):
    for index in range(len(data)-1, -1, -1):
        yield data[index]

>>> for char in reverse('golf'):
...     print(char)
...
f
l
o
g
```

ジェネレータでできることは全て、前のセクションで説明したクラスベースのイテレータでもできる。

**ジェネレータをこんなにコンパクトにしてるもの:**
- `__iter__()`と`__next__()`メソッドが自動的に作られる
- ローカル変数と実行状態が呼び出し間で自動的に保存される
  - これで関数を書くのが簡単になり、`self.index`や`self.data`みたいなインスタンス変数を使うアプローチよりずっと明確になる
- 自動的なメソッド作成とプログラム状態の保存に加えて、ジェネレータが終了すると自動的に`StopIteration`を発生させる

これらの機能を組み合わせることで、通常の関数を書くのと同じくらいの労力でイテレータを簡単に作れるんだ。

---

## 9.10. ジェネレータ式 (Generator Expressions)

シンプルなジェネレータには、リスト内包表記に似た構文を使って、簡潔に式としてコーディングできるものがある。でも、角括弧の代わりに括弧を使うよ。

これらの式は、ジェネレータが囲んでる関数ですぐに使われる状況向けに設計されてる。

**ジェネレータ式は:**
- 完全なジェネレータ定義よりコンパクト
- でも汎用性は低い
- 同等のリスト内包表記よりメモリに優しい傾向がある

例:

```python
>>> sum(i*i for i in range(10))  # 平方の合計
285

>>> xvec = [10, 20, 30]
>>> yvec = [7, 5, 3]
>>> sum(x*y for x,y in zip(xvec, yvec))  # ドット積
260

>>> unique_words = set(word for line in page for word in line.split())

>>> valedictorian = max((student.gpa, student.name) for student in graduates)

>>> data = 'golf'
>>> list(data[i] for i in range(len(data)-1, -1, -1))
['f', 'l', 'o', 'g']
```

---

## 脚注

**[1]** 1つだけ例外がある。モジュールオブジェクトには`__dict__`という秘密の読み取り専用属性があって、これはモジュールの名前空間を実装するのに使われる辞書を返す。名前`__dict__`は属性だけど、グローバル名じゃない。

明らかに、これを使うことは名前空間実装の抽象化を破るから、死後デバッガのようなものに制限すべきだよ。

---

# 試験対策 - 重要ポイントまとめ

## 📌 クラスの基本

### クラスとは
- **データと機能をまとめる仕組み**
- クラスを作ると新しい「型」ができる
- その型の「インスタンス」を複数作れる

### クラス定義の基本形
```python
class ClassName:
    def __init__(self):  # 初期化メソッド
        self.data = []   # インスタンス変数
```

### 重要な用語
- **インスタンス** = クラスから作られた実体
- **属性(attribute)** = オブジェクトが持つデータや関数
- **メソッド** = クラスに属する関数
- **self** = メソッドの第1引数(インスタンス自身を指す)

---

## 📌 名前空間とスコープ

### 名前空間 (Namespace)
- **名前からオブジェクトへのマッピング**(辞書のようなもの)
- 異なる名前空間の名前同士は無関係

### スコープの検索順序(内側→外側)
1. **ローカルスコープ** - 関数内のローカル変数
2. **外側の関数のスコープ** - ネストした関数の外側の変数
3. **グローバルスコープ** - モジュールレベルの変数
4. **ビルトインスコープ** - 組み込み関数・例外

### global と nonlocal
```python
def test():
    global x      # グローバル変数を変更
    nonlocal y    # 外側の関数の変数を変更
```

---

## 📌 クラス変数 vs インスタンス変数

### クラス変数
- **全インスタンスで共有**
- クラス定義内で直接定義

```python
class Dog:
    kind = 'canine'  # クラス変数(全インスタンスで共有)
```

### インスタンス変数
- **各インスタンスに固有**
- 通常`__init__`内で定義

```python
class Dog:
    def __init__(self, name):
        self.name = name  # インスタンス変数(個別)
```

### ⚠️ 重要な注意点
- **ミュータブルなオブジェクト(リスト・辞書)をクラス変数にしない!**
- 全インスタンスで共有されて予期しない動作になる

```python
# ❌ 悪い例
class Dog:
    tricks = []  # 全インスタンスで共有されちゃう!

# ✅ 良い例
class Dog:
    def __init__(self):
        self.tricks = []  # 各インスタンス専用
```

---

## 📌 特殊メソッド

### `__init__`
- **初期化メソッド**(コンストラクタ)
- インスタンス作成時に自動で呼ばれる

```python
class MyClass:
    def __init__(self, value):
        self.value = value

x = MyClass(10)  # __init__が自動で呼ばれる
```

### `__str__` と `__repr__`
- `__str__` - 人間が読みやすい文字列
- `__repr__` - 開発者向けの詳細な文字列

### その他の重要な特殊メソッド
- `__len__` - `len(obj)`で呼ばれる
- `__add__` - `+`演算子
- `__eq__` - `==`演算子

---

## 📌 継承 (Inheritance)

### 基本の継承
```python
class DerivedClass(BaseClass):
    pass
```

### メソッドのオーバーライド
- 子クラスで親クラスのメソッドを上書きできる
- Pythonの全メソッドは「virtual」(常にオーバーライド可能)

### 親クラスのメソッドを呼ぶ
```python
class Child(Parent):
    def method(self):
        Parent.method(self)  # 親のメソッドを呼ぶ
        # または
        super().method()     # こっちが推奨
```

### 継承チェック関数
- `isinstance(obj, ClassName)` - objがClassNameのインスタンスか
- `issubclass(Child, Parent)` - ChildがParentのサブクラスか

### 多重継承
```python
class Child(Parent1, Parent2, Parent3):
    pass
```
- **検索順序**: 深さ優先、左から右
- **MRO(メソッド解決順序)** は動的に決定される

---

## 📌 プライベート変数

### アンダースコアの意味
- `_single` - 「内部用」の慣習(プライベートではない)
- `__double` - 名前マングリングされる

### 名前マングリング
```python
class MyClass:
    def __init__(self):
        self.__private = 10  # _MyClass__privateに変換される
```
- `__spam` → `_ClassName__spam`に自動変換
- サブクラスでの名前衝突を避けるため

---

## 📌 イテレータとジェネレータ

### イテレータ
- `__iter__()` - イテレータオブジェクトを返す
- `__next__()` - 次の要素を返す、なければ`StopIteration`

```python
class Reverse:
    def __init__(self, data):
        self.data = data
        self.index = len(data)
    
    def __iter__(self):
        return self
    
    def __next__(self):
        if self.index == 0:
            raise StopIteration
        self.index -= 1
        return self.data[self.index]
```

### ジェネレータ
- **`yield`を使う関数**
- 自動的に`__iter__`と`__next__`が作られる
- 状態を自動で保存

```python
def reverse(data):
    for i in range(len(data)-1, -1, -1):
        yield data[i]
```

### ジェネレータ式
- リスト内包表記の`[]`を`()`に変更
- メモリ効率が良い

```python
# リスト内包表記
squares_list = [x*x for x in range(10)]

# ジェネレータ式
squares_gen = (x*x for x in range(10))
```

---

## 📌 試験頻出ポイント

### 1. メソッド呼び出し
- `x.method()` = `ClassName.method(x)`
- selfは自動で渡される

### 2. 属性検索順序
1. インスタンス属性
2. クラス属性
3. 親クラスの属性(継承している場合)

### 3. `__init__`の役割
- インスタンス作成時の初期化
- `self`を通じてインスタンス変数を設定

### 4. クラス変数の共有
- クラス変数は**全インスタンスで共有**
- ミュータブルなオブジェクトは注意!

### 5. 継承時のメソッド解決
- 子クラス → 親クラスの順で検索
- `super()`で親クラスのメソッドを呼べる

### 6. プライベート変数
- Pythonに真のプライベートはない
- `_`は慣習、`__`は名前マングリング

### 7. イテレータとジェネレータの違い
- **イテレータ**: `__iter__`と`__next__`を実装したクラス
- **ジェネレータ**: `yield`を使う関数(自動でイテレータになる)

### 8. for文の裏側
```python
for item in container:
    # ...
```
は、実際には:
```python
iterator = iter(container)  # __iter__()を呼ぶ
while True:
    try:
        item = next(iterator)  # __next__()を呼ぶ
        # ...
    except StopIteration:
        break
```

---

## 🎯 よくある間違い

### ❌ 間違い1: ミュータブルなデフォルト引数
```python
# ダメ!
def __init__(self, items=[]):
    self.items = items

# 良い!
def __init__(self, items=None):
    self.items = items if items is not None else []
```

### ❌ 間違い2: selfを忘れる
```python
class MyClass:
    def method():  # ❌ selfがない!
        pass
    
    def method(self):  # ✅ 正しい
        pass
```

### ❌ 間違い3: クラス変数とインスタンス変数の混同
```python
class Wrong:
    data = []  # ❌ クラス変数(全インスタンスで共有)

class Right:
    def __init__(self):
        self.data = []  # ✅ インスタンス変数
```

---

## 📚 覚えておくべきキーワード

- `class` - クラス定義
- `def` - メソッド定義
- `self` - インスタンス自身
- `__init__` - 初期化メソッド
- `super()` - 親クラスへのアクセス
- `isinstance()` - 型チェック
- `issubclass()` - 継承チェック
- `yield` - ジェネレータ
- `global` - グローバル変数宣言
- `nonlocal` - 外側のスコープの変数宣言

---

## 🔥 最後の確認ポイント

1. ✅ クラスとインスタンスの違いを説明できる?
2. ✅ クラス変数とインスタンス変数の違いは?
3. ✅ `self`の役割は?
4. ✅ `__init__`はいつ呼ばれる?
5. ✅ 継承時のメソッド検索順序は?
6. ✅ イテレータの条件(`__iter__`と`__next__`)は?
7. ✅ ジェネレータの作り方は?
8. ✅ 名前マングリング(`__`)の仕組みは?

あんじゅ、試験頑張ってね! ( ˶ˆᴗˆ˶)♡